
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package sintactico;

import backend.BackTables;
import c3a.GeneratorC3A;
import c3a.InstructionC3A.Code;
import errores.CompilerError;
import errores.SymTabError;
import generatorAssembler.GeneratorAssembler;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import java_cup.runtime.Symbol;
import lexico.Lexico;
import core.*;
import symbolsTable.SymbolsTable;
import symbolsTable.Type;
import symbolsTable.Type.Tipo;
import symbolsTable.Type.TipoSubyacente;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java_cup.runtime.ComplexSymbolFactory.Location;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return ParserSym.class;
}

  /** Default constructor. */
  @Deprecated
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\156\000\002\002\004\000\002\002\004\000\002\003" +
    "\002\000\002\050\004\000\002\050\003\000\002\051\011" +
    "\000\002\052\010\000\002\053\003\000\002\053\003\000" +
    "\002\054\007\000\002\054\006\000\002\055\003\000\002" +
    "\055\002\000\002\056\005\000\002\056\003\000\002\005" +
    "\014\000\002\004\002\000\002\006\003\000\002\006\003" +
    "\000\002\007\004\000\002\007\003\000\002\010\004\000" +
    "\002\010\004\000\002\010\003\000\002\010\003\000\002" +
    "\010\003\000\002\010\004\000\002\010\004\000\002\010" +
    "\004\000\002\011\002\000\002\012\002\000\002\013\005" +
    "\000\002\013\003\000\002\061\007\000\002\062\005\000" +
    "\002\062\003\000\002\063\005\000\002\014\010\000\002" +
    "\014\010\000\002\015\003\000\002\015\003\000\002\023" +
    "\005\000\002\025\003\000\002\025\003\000\002\026\005" +
    "\000\002\026\006\000\002\026\005\000\002\016\003\000" +
    "\002\016\005\000\002\016\004\000\002\027\003\000\002" +
    "\027\003\000\002\027\003\000\002\027\003\000\002\027" +
    "\004\000\002\017\003\000\002\017\005\000\002\017\004" +
    "\000\002\017\004\000\002\020\003\000\002\020\005\000" +
    "\002\022\003\000\002\022\003\000\002\022\003\000\002" +
    "\022\003\000\002\022\003\000\002\022\004\000\002\022" +
    "\003\000\002\022\003\000\002\022\003\000\002\022\005" +
    "\000\002\064\005\000\002\065\005\000\002\065\003\000" +
    "\002\030\005\000\002\030\005\000\002\030\006\000\002" +
    "\031\003\000\002\031\003\000\002\031\003\000\002\031" +
    "\003\000\002\031\004\000\002\031\003\000\002\031\004" +
    "\000\002\021\003\000\002\021\004\000\002\021\005\000" +
    "\002\032\007\000\002\032\005\000\002\034\003\000\002" +
    "\036\002\000\002\035\002\000\002\037\014\000\002\033" +
    "\003\000\002\040\015\000\002\040\002\000\002\041\012" +
    "\000\002\041\003\000\002\042\003\000\002\046\013\000" +
    "\002\047\014\000\002\044\003\000\002\043\011\000\002" +
    "\045\003\000\002\057\005\000\002\057\004\000\002\060" +
    "\005\000\002\060\005\000\002\024\006\000\002\066\002" +
    "" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\373\000\004\023\uffff\001\002\000\004\023\007\001" +
    "\002\000\004\002\006\001\002\000\004\002\001\001\002" +
    "\000\006\004\345\042\346\001\002\000\004\002\000\001" +
    "\002\000\004\002\ufffd\001\002\000\004\033\015\001\002" +
    "\000\004\023\007\001\002\000\004\002\ufffe\001\002\000" +
    "\022\004\uffe4\010\uffe4\017\uffe4\022\uffe4\024\uffe4\026\uffe4" +
    "\030\uffe4\034\uffe4\001\002\000\022\004\027\010\022\017" +
    "\026\022\024\024\ufff5\026\041\030\036\034\ufff5\001\002" +
    "\000\004\037\uffe1\001\002\000\004\037\344\001\002\000" +
    "\022\004\027\010\022\017\026\022\024\024\ufff6\026\041" +
    "\030\036\034\ufff6\001\002\000\004\033\332\001\002\000" +
    "\004\037\331\001\002\000\014\004\uff94\007\uff94\013\uff94" +
    "\015\uff94\031\uff94\001\002\000\022\004\uffe9\010\uffe9\017" +
    "\uffe9\022\uffe9\024\uffe9\026\uffe9\030\uffe9\034\uffe9\001\002" +
    "\000\014\004\060\007\053\013\057\015\051\031\063\001" +
    "\002\000\014\016\203\025\221\031\205\040\257\041\uff94" +
    "\001\002\000\006\032\255\040\254\001\002\000\004\037" +
    "\253\001\002\000\022\004\uffe8\010\uffe8\017\uffe8\022\uffe8" +
    "\024\uffe8\026\uffe8\030\uffe8\034\uffe8\001\002\000\004\037" +
    "\252\001\002\000\006\024\243\034\uff94\001\002\000\004" +
    "\037\242\001\002\000\004\031\237\001\002\000\022\004" +
    "\uffed\010\uffed\017\uffed\022\uffed\024\uffed\026\uffed\030\uffed" +
    "\034\uffed\001\002\000\022\004\uffea\010\uffea\017\uffea\022" +
    "\uffea\024\uffea\026\uffea\030\uffea\034\uffea\001\002\000\004" +
    "\031\042\001\002\000\004\004\043\001\002\000\006\025" +
    "\221\041\uff94\001\002\000\004\032\211\001\002\000\004" +
    "\037\046\001\002\000\014\004\uff94\007\uff94\013\uff94\015" +
    "\uff94\031\uff94\001\002\000\014\004\uff9c\007\uff9c\013\uff9c" +
    "\015\uff9c\031\uff9c\001\002\000\014\004\060\007\053\013" +
    "\057\015\051\031\063\001\002\000\012\004\127\013\117" +
    "\015\051\031\131\001\002\000\020\011\uffb2\012\uffb2\032" +
    "\uffb2\033\uffb2\036\uffb2\037\uffb2\040\uffb2\001\002\000\020" +
    "\011\uffad\012\uffad\032\uffad\033\uffad\036\uffad\037\uffad\040" +
    "\uffad\001\002\000\020\011\uffb3\012\uffb3\032\uffb3\033\uffb3" +
    "\036\uffb3\037\uffb3\040\uffb3\001\002\000\020\011\uffaf\012" +
    "\uffaf\032\uffaf\033\uffaf\036\uffaf\037\uffaf\040\uffaf\001\002" +
    "\000\010\012\174\033\uffa8\037\uffa8\001\002\000\014\004" +
    "\060\007\053\013\160\015\051\031\162\001\002\000\026" +
    "\011\uffca\012\uffca\014\uffca\015\uffca\031\205\032\uffca\033" +
    "\uffca\036\uffca\037\uffca\040\uffca\001\002\000\004\037\176" +
    "\001\002\000\020\011\uffb1\012\uffb1\032\uffb1\033\uffb1\036" +
    "\uffb1\037\uffb1\040\uffb1\001\002\000\022\004\060\005\100" +
    "\006\077\007\053\013\073\015\075\027\067\031\076\001" +
    "\002\000\020\011\uffb4\012\uffb4\032\uffb4\033\uffb4\036\uffb4" +
    "\037\uffb4\040\uffb4\001\002\000\004\012\174\001\002\000" +
    "\010\011\uffc2\012\uffb4\032\170\001\002\000\004\031\172" +
    "\001\002\000\014\011\uffc3\032\uffc3\036\uffc3\037\uffc3\040" +
    "\uffc3\001\002\000\010\011\uffbd\012\uffb2\032\171\001\002" +
    "\000\022\011\uffbc\012\uffaf\014\uffcc\015\uffcc\032\uffbc\036" +
    "\uffbc\037\uffbc\040\uffbc\001\002\000\014\004\060\007\053" +
    "\013\160\015\051\031\162\001\002\000\020\011\uffc1\014" +
    "\uffcf\015\uffcf\032\uffc1\036\uffc1\037\uffc1\040\uffc1\001\002" +
    "\000\014\004\060\005\100\013\117\015\146\031\152\001" +
    "\002\000\022\004\060\005\100\006\077\007\053\013\073" +
    "\015\075\027\067\031\076\001\002\000\014\011\uffc6\032" +
    "\uffc6\036\uffc6\037\uffc6\040\uffc6\001\002\000\020\011\uffd2" +
    "\014\uffd2\015\uffd2\032\uffd2\036\uffd2\037\uffd2\040\uffd2\001" +
    "\002\000\004\011\133\001\002\000\020\011\uffbe\014\uffcd" +
    "\015\uffcd\032\uffbe\036\uffbe\037\uffbe\040\uffbe\001\002\000" +
    "\006\014\110\015\111\001\002\000\014\011\uffc4\012\uffb3" +
    "\014\uffce\015\uffce\032\107\001\002\000\010\011\uffc0\012" +
    "\uffb1\032\106\001\002\000\020\011\uffa9\012\uffa9\032\uffa9" +
    "\033\uffa9\036\uffa9\037\uffa9\040\uffa9\001\002\000\024\011" +
    "\uffc9\012\uffc9\014\uffc9\015\uffc9\032\uffc9\033\uffc9\036\uffc9" +
    "\037\uffc9\040\uffc9\001\002\000\014\004\uffd6\005\uffd6\013" +
    "\uffd6\015\uffd6\031\uffd6\001\002\000\014\004\uffd7\005\uffd7" +
    "\013\uffd7\015\uffd7\031\uffd7\001\002\000\014\004\060\005" +
    "\100\013\117\015\075\031\121\001\002\000\020\011\uffcd" +
    "\014\uffcd\015\uffcd\032\uffcd\036\uffcd\037\uffcd\040\uffcd\001" +
    "\002\000\020\011\uffce\014\uffce\015\uffce\032\uffce\036\uffce" +
    "\037\uffce\040\uffce\001\002\000\020\011\uffcc\014\uffcc\015" +
    "\uffcc\032\uffcc\036\uffcc\037\uffcc\040\uffcc\001\002\000\020" +
    "\011\uffd5\014\110\015\111\032\uffd5\036\uffd5\037\uffd5\040" +
    "\uffd5\001\002\000\012\004\127\013\117\015\051\031\131" +
    "\001\002\000\020\011\uffcf\014\uffcf\015\uffcf\032\uffcf\036" +
    "\uffcf\037\uffcf\040\uffcf\001\002\000\014\004\060\005\100" +
    "\013\117\015\075\031\121\001\002\000\010\014\uffcd\015" +
    "\uffcd\032\126\001\002\000\010\014\uffce\015\uffce\032\107" +
    "\001\002\000\010\014\uffcf\015\uffcf\032\125\001\002\000" +
    "\020\011\uffd1\014\uffd1\015\uffd1\032\uffd1\036\uffd1\037\uffd1" +
    "\040\uffd1\001\002\000\020\011\uffd3\014\uffd3\015\uffd3\032" +
    "\uffd3\036\uffd3\037\uffd3\040\uffd3\001\002\000\024\011\uffca" +
    "\012\uffca\014\uffca\015\uffca\032\uffca\033\uffca\036\uffca\037" +
    "\uffca\040\uffca\001\002\000\024\011\uffc8\012\uffc8\014\uffc8" +
    "\015\uffc8\032\uffc8\033\uffc8\036\uffc8\037\uffc8\040\uffc8\001" +
    "\002\000\012\004\127\013\117\015\051\031\131\001\002" +
    "\000\004\032\107\001\002\000\022\004\060\005\100\006" +
    "\077\007\053\013\073\015\075\027\067\031\076\001\002" +
    "\000\014\012\uffb4\032\uffc2\036\uffc2\037\uffc2\040\uffc2\001" +
    "\002\000\014\012\uffb2\032\uffbd\036\uffbd\037\uffbd\040\uffbd" +
    "\001\002\000\004\032\141\001\002\000\020\012\uffb3\014" +
    "\uffce\015\uffce\032\uffc4\036\uffc4\037\uffc4\040\uffc4\001\002" +
    "\000\014\012\uffb1\032\uffc0\036\uffc0\037\uffc0\040\uffc0\001" +
    "\002\000\020\011\uffaa\012\uffaa\032\uffaa\033\uffaa\036\uffaa" +
    "\037\uffaa\040\uffaa\001\002\000\006\011\uffc3\032\145\001" +
    "\002\000\012\011\uffc1\014\uffcf\015\uffcf\032\125\001\002" +
    "\000\012\011\uffbe\014\uffcd\015\uffcd\032\126\001\002\000" +
    "\014\011\uffc5\032\uffc5\036\uffc5\037\uffc5\040\uffc5\001\002" +
    "\000\014\004\127\005\100\013\117\015\146\031\155\001" +
    "\002\000\024\011\uffc7\012\uffc7\014\uffc7\015\uffc7\032\uffc7" +
    "\033\uffc7\036\uffc7\037\uffc7\040\uffc7\001\002\000\020\011" +
    "\uffcb\014\uffcb\015\uffcb\032\uffcb\036\uffcb\037\uffcb\040\uffcb" +
    "\001\002\000\020\011\uffd0\014\uffd0\015\uffd0\032\uffd0\036" +
    "\uffd0\037\uffd0\040\uffd0\001\002\000\014\004\060\005\100" +
    "\013\117\015\075\031\121\001\002\000\010\014\uffcd\015" +
    "\uffcd\032\154\001\002\000\020\011\uffd4\014\uffd4\015\uffd4" +
    "\032\uffd4\036\uffd4\037\uffd4\040\uffd4\001\002\000\014\004" +
    "\127\005\100\013\117\015\146\031\155\001\002\000\004" +
    "\032\125\001\002\000\020\011\uffae\012\uffae\032\uffae\033" +
    "\uffae\036\uffae\037\uffae\040\uffae\001\002\000\014\004\127" +
    "\007\053\013\160\015\051\031\166\001\002\000\016\011" +
    "\uffbf\012\uffb0\032\uffbf\036\uffbf\037\uffbf\040\uffbf\001\002" +
    "\000\022\004\060\005\100\006\077\007\053\013\073\015" +
    "\075\027\067\031\076\001\002\000\020\011\uffac\012\uffac" +
    "\032\uffac\033\uffac\036\uffac\037\uffac\040\uffac\001\002\000" +
    "\010\011\uffbd\012\uffb2\032\165\001\002\000\020\011\uffb5" +
    "\012\uffb5\032\uffb5\033\uffb5\036\uffb5\037\uffb5\040\uffb5\001" +
    "\002\000\014\004\127\007\053\013\160\015\051\031\166" +
    "\001\002\000\004\032\170\001\002\000\020\011\uffab\012" +
    "\uffab\032\uffab\033\uffab\036\uffab\037\uffab\040\uffab\001\002" +
    "\000\020\011\uffb6\012\uffb6\032\uffb6\033\uffb6\036\uffb6\037" +
    "\uffb6\040\uffb6\001\002\000\004\032\173\001\002\000\014" +
    "\011\uffbb\032\uffbb\036\uffbb\037\uffbb\040\uffbb\001\002\000" +
    "\014\004\060\007\053\013\057\015\051\031\063\001\002" +
    "\000\020\011\uffb7\012\uffb7\032\uffb7\033\uffb7\036\uffb7\037" +
    "\uffb7\040\uffb7\001\002\000\004\004\uff94\001\002\000\004" +
    "\004\201\001\002\000\004\004\uff9a\001\002\000\004\016" +
    "\203\001\002\000\004\032\uff9b\001\002\000\022\004\060" +
    "\005\100\006\077\007\053\013\073\015\075\027\067\031" +
    "\076\001\002\000\006\032\uffd8\037\uffd8\001\002\000\024" +
    "\004\060\005\100\006\077\007\053\013\073\015\075\027" +
    "\067\031\076\032\206\001\002\000\024\011\uff99\012\uff99" +
    "\014\uff99\015\uff99\032\uff99\033\uff99\036\uff99\037\uff99\040" +
    "\uff99\001\002\000\006\032\uff96\040\uff96\001\002\000\020" +
    "\011\uffb0\012\uffb0\032\uffb0\033\uffb0\036\uffb0\037\uffb0\040" +
    "\uffb0\001\002\000\004\033\212\001\002\000\016\004\uffe4" +
    "\010\uffe4\017\uffe4\022\uffe4\026\uffe4\030\uffe4\001\002\000" +
    "\016\004\uffa7\010\uffa7\017\uffa7\022\uffa7\026\uffa7\030\uffa7" +
    "\001\002\000\016\004\027\010\022\017\026\022\024\026" +
    "\041\030\036\001\002\000\020\004\027\010\022\017\026" +
    "\022\024\026\041\030\036\034\uffe3\001\002\000\004\034" +
    "\220\001\002\000\022\004\uffee\010\uffee\017\uffee\022\uffee" +
    "\024\uffee\026\uffee\030\uffee\034\uffee\001\002\000\022\004" +
    "\uff9d\010\uff9d\017\uff9d\022\uff9d\024\uff9d\026\uff9d\030\uff9d" +
    "\034\uff9d\001\002\000\004\041\uffda\001\002\000\004\041" +
    "\224\001\002\000\004\041\uffd9\001\002\000\004\004\225" +
    "\001\002\000\004\016\226\001\002\000\024\004\060\005" +
    "\100\006\077\007\053\013\073\015\075\027\067\031\076" +
    "\035\230\001\002\000\004\037\uffdb\001\002\000\022\004" +
    "\060\005\100\006\077\007\053\013\073\015\075\027\067" +
    "\031\076\001\002\000\004\037\uffdc\001\002\000\006\036" +
    "\235\040\234\001\002\000\006\036\uffb8\040\uffb8\001\002" +
    "\000\022\004\060\005\100\006\077\007\053\013\073\015" +
    "\075\027\067\031\076\001\002\000\004\037\uffba\001\002" +
    "\000\006\036\uffb9\040\uffb9\001\002\000\022\004\060\005" +
    "\100\006\077\007\053\013\073\015\075\027\067\031\076" +
    "\001\002\000\004\032\241\001\002\000\004\037\uff95\001" +
    "\002\000\022\004\uffec\010\uffec\017\uffec\022\uffec\024\uffec" +
    "\026\uffec\030\uffec\034\uffec\001\002\000\022\004\060\005" +
    "\100\006\077\007\053\013\073\015\075\027\067\031\076" +
    "\001\002\000\004\034\ufff3\001\002\000\004\034\uffe3\001" +
    "\002\000\004\034\247\001\002\000\004\023\ufffc\001\002" +
    "\000\004\037\251\001\002\000\004\034\ufff4\001\002\000" +
    "\022\004\uffeb\010\uffeb\017\uffeb\022\uffeb\024\uffeb\026\uffeb" +
    "\030\uffeb\034\uffeb\001\002\000\022\004\uffe6\010\uffe6\017" +
    "\uffe6\022\uffe6\024\uffe6\026\uffe6\030\uffe6\034\uffe6\001\002" +
    "\000\022\004\060\005\100\006\077\007\053\013\073\015" +
    "\075\027\067\031\076\001\002\000\024\011\uff98\012\uff98" +
    "\014\uff98\015\uff98\032\uff98\033\uff98\036\uff98\037\uff98\040" +
    "\uff98\001\002\000\006\032\uff97\040\uff97\001\002\000\004" +
    "\004\260\001\002\000\010\025\221\040\257\041\uff94\001" +
    "\002\000\004\037\uffe2\001\002\000\004\033\263\001\002" +
    "\000\016\004\uffe4\010\uffe4\017\uffe4\022\uffe4\026\uffe4\030" +
    "\uffe4\001\002\000\016\004\uffa7\010\uffa7\017\uffa7\022\uffa7" +
    "\026\uffa7\030\uffa7\001\002\000\016\004\027\010\022\017" +
    "\026\022\024\026\041\030\036\001\002\000\020\004\027" +
    "\010\022\017\026\022\024\026\041\030\036\034\uffe3\001" +
    "\002\000\004\034\270\001\002\000\026\004\uffa2\010\uffa2" +
    "\017\uffa2\020\uff94\021\uffa2\022\uffa2\024\uffa2\026\uffa2\030" +
    "\uffa2\034\uffa2\001\002\000\024\004\uffa6\010\uffa6\017\uffa6" +
    "\021\uff94\022\uffa6\024\uffa6\026\uffa6\030\uffa6\034\uffa6\001" +
    "\002\000\004\020\274\001\002\000\006\020\uffa4\021\uffa4" +
    "\001\002\000\014\004\uffa6\007\uffa6\013\uffa6\015\uffa6\031" +
    "\uffa6\001\002\000\014\004\060\007\053\013\057\015\051" +
    "\031\063\001\002\000\004\033\277\001\002\000\016\004" +
    "\uffe4\010\uffe4\017\uffe4\022\uffe4\026\uffe4\030\uffe4\001\002" +
    "\000\016\004\uffa7\010\uffa7\017\uffa7\022\uffa7\026\uffa7\030" +
    "\uffa7\001\002\000\016\004\027\010\022\017\026\022\024" +
    "\026\041\030\036\001\002\000\020\004\027\010\022\017" +
    "\026\022\024\026\041\030\036\034\uffe3\001\002\000\004" +
    "\034\304\001\002\000\026\004\uffa2\010\uffa2\017\uffa2\020" +
    "\uff94\021\uffa2\022\uffa2\024\uffa2\026\uffa2\030\uffa2\034\uffa2" +
    "\001\002\000\024\004\uffa3\010\uffa3\017\uffa3\021\uffa3\022" +
    "\uffa3\024\uffa3\026\uffa3\030\uffa3\034\uffa3\001\002\000\022" +
    "\004\uffa5\010\uffa5\017\uffa5\022\uffa5\024\uffa5\026\uffa5\030" +
    "\uffa5\034\uffa5\001\002\000\022\004\uffa0\010\uffa0\017\uffa0" +
    "\022\uffa0\024\uffa0\026\uffa0\030\uffa0\034\uffa0\001\002\000" +
    "\004\021\311\001\002\000\004\033\312\001\002\000\016" +
    "\004\uffe4\010\uffe4\017\uffe4\022\uffe4\026\uffe4\030\uffe4\001" +
    "\002\000\016\004\uffa6\010\uffa6\017\uffa6\022\uffa6\026\uffa6" +
    "\030\uffa6\001\002\000\016\004\027\010\022\017\026\022" +
    "\024\026\041\030\036\001\002\000\020\004\027\010\022" +
    "\017\026\022\024\026\041\030\036\034\uffe3\001\002\000" +
    "\004\034\317\001\002\000\022\004\uffa1\010\uffa1\017\uffa1" +
    "\022\uffa1\024\uffa1\026\uffa1\030\uffa1\034\uffa1\001\002\000" +
    "\014\004\060\007\053\013\057\015\051\031\063\001\002" +
    "\000\014\004\uff9f\007\uff9f\013\uff9f\015\uff9f\031\uff9f\001" +
    "\002\000\004\033\323\001\002\000\016\004\uffe4\010\uffe4" +
    "\017\uffe4\022\uffe4\026\uffe4\030\uffe4\001\002\000\016\004" +
    "\uffa7\010\uffa7\017\uffa7\022\uffa7\026\uffa7\030\uffa7\001\002" +
    "\000\016\004\027\010\022\017\026\022\024\026\041\030" +
    "\036\001\002\000\020\004\027\010\022\017\026\022\024" +
    "\026\041\030\036\034\uffe3\001\002\000\004\034\330\001" +
    "\002\000\022\004\uff9e\010\uff9e\017\uff9e\022\uff9e\024\uff9e" +
    "\026\uff9e\030\uff9e\034\uff9e\001\002\000\022\004\uffe5\010" +
    "\uffe5\017\uffe5\022\uffe5\024\uffe5\026\uffe5\030\uffe5\034\uffe5" +
    "\001\002\000\004\004\333\001\002\000\004\041\342\001" +
    "\002\000\006\034\uffde\037\uffde\001\002\000\006\034\337" +
    "\037\336\001\002\000\004\004\333\001\002\000\004\004" +
    "\340\001\002\000\004\037\uffe0\001\002\000\006\034\uffdf" +
    "\037\uffdf\001\002\000\004\004\343\001\002\000\006\034" +
    "\uffdd\037\uffdd\001\002\000\022\004\uffe7\010\uffe7\017\uffe7" +
    "\022\uffe7\024\uffe7\026\uffe7\030\uffe7\034\uffe7\001\002\000" +
    "\004\031\363\001\002\000\004\031\ufff1\001\002\000\004" +
    "\031\350\001\002\000\004\032\351\001\002\000\004\033" +
    "\352\001\002\000\020\004\uffe4\010\uffe4\017\uffe4\022\uffe4" +
    "\026\uffe4\030\uffe4\034\uffe4\001\002\000\020\004\027\010" +
    "\022\017\026\022\024\026\041\030\036\034\uff94\001\002" +
    "\000\020\004\027\010\022\017\026\022\024\026\041\030" +
    "\036\034\ufff0\001\002\000\004\034\uffe3\001\002\000\004" +
    "\034\uffef\001\002\000\004\034\360\001\002\000\004\002" +
    "\ufff2\001\002\000\006\032\ufffa\040\372\001\002\000\004" +
    "\032\367\001\002\000\006\004\364\032\ufff9\001\002\000" +
    "\004\041\365\001\002\000\004\004\366\001\002\000\006" +
    "\032\ufff7\040\ufff7\001\002\000\004\041\370\001\002\000" +
    "\004\004\371\001\002\000\004\033\ufffb\001\002\000\004" +
    "\004\373\001\002\000\004\041\374\001\002\000\004\004" +
    "\375\001\002\000\006\032\ufff8\040\ufff8\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\373\000\006\002\004\003\003\001\001\000\012\005" +
    "\010\050\007\051\012\052\011\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\012\005\010\050\013" +
    "\051\012\052\011\001\001\000\002\001\001\000\004\011" +
    "\015\001\001\000\034\007\020\010\036\013\034\014\016" +
    "\023\017\024\030\037\037\046\024\047\031\055\033\057" +
    "\022\060\027\061\032\001\001\000\002\001\001\000\002" +
    "\001\001\000\030\010\216\013\034\014\016\023\017\024" +
    "\030\037\037\046\024\047\031\057\022\060\027\061\032" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\042" +
    "\317\066\320\001\001\000\002\001\001\000\022\017\053" +
    "\021\063\030\051\031\055\032\061\034\261\057\054\060" +
    "\027\001\001\000\006\015\221\066\222\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\056\244\066\243\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\014\044\043\043\001\001\000\006" +
    "\015\221\066\222\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\044\047\066\046\001\001\000\002\001\001" +
    "\000\022\017\053\021\063\030\051\031\055\032\061\034" +
    "\060\057\054\060\027\001\001\000\004\017\146\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\014\017\127\021\162" +
    "\032\207\057\156\060\027\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\032\016\073\017\103" +
    "\020\067\021\065\022\100\026\101\027\102\030\070\031" +
    "\064\032\104\057\071\060\027\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\014" +
    "\017\127\021\162\032\160\057\156\060\027\001\001\000" +
    "\002\001\001\000\012\016\150\017\146\057\147\060\027" +
    "\001\001\000\032\016\142\017\103\020\141\021\065\022" +
    "\100\026\143\027\102\030\070\031\064\032\104\057\071" +
    "\060\027\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\025\111\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\016" +
    "\016\117\017\113\026\112\027\115\057\114\060\027\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\025\111\001\001\000\004\017\127\001\001\000" +
    "\002\001\001\000\016\016\123\017\122\026\121\027\102" +
    "\057\114\060\027\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\017\131\001" +
    "\001\000\002\001\001\000\032\016\073\017\136\020\067" +
    "\021\133\022\135\026\101\027\102\030\134\031\064\032" +
    "\137\057\071\060\027\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\016\150\017" +
    "\146\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\016\016\123\017\122\026\152\027\102\057" +
    "\114\060\027\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\016\155\017\131\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\017\127\021\162\001\001\000\002" +
    "\001\001\000\032\016\073\017\103\020\067\021\065\022" +
    "\100\026\101\027\102\030\163\031\064\032\104\057\071" +
    "\060\027\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\017\131\021\166\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\020\017\053\021\063\030\051" +
    "\031\174\032\061\057\054\060\027\001\001\000\002\001" +
    "\001\000\006\045\176\066\177\001\001\000\004\023\201" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\032\016\073\017\136\020\067\021\133\022\203" +
    "\026\101\027\102\030\134\031\064\032\137\057\071\060" +
    "\027\001\001\000\002\001\001\000\032\016\073\017\136" +
    "\020\067\021\133\022\206\026\101\027\102\030\134\031" +
    "\064\032\137\057\071\060\027\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\011\212\001\001\000\004\036\213\001\001\000\032" +
    "\007\214\010\036\013\034\014\016\023\017\024\030\037" +
    "\037\046\024\047\031\057\022\060\027\061\032\001\001" +
    "\000\032\010\216\012\215\013\034\014\016\023\017\024" +
    "\030\037\037\046\024\047\031\057\022\060\027\061\032" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\034\016\073\017" +
    "\136\020\067\021\133\022\230\026\101\027\102\030\134" +
    "\031\064\032\137\057\071\060\027\064\226\001\001\000" +
    "\002\001\001\000\034\016\073\017\136\020\067\021\133" +
    "\022\232\026\101\027\102\030\134\031\064\032\137\057" +
    "\071\060\027\065\231\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\032\016\073\017\136\020" +
    "\067\021\133\022\235\026\101\027\102\030\134\031\064" +
    "\032\137\057\071\060\027\001\001\000\002\001\001\000" +
    "\002\001\001\000\032\016\073\017\136\020\067\021\133" +
    "\022\237\026\101\027\102\030\134\031\064\032\137\057" +
    "\071\060\027\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\032\016\073\017\136\020\067\021" +
    "\133\022\247\026\101\027\102\030\134\031\064\032\137" +
    "\057\071\060\027\001\001\000\002\001\001\000\004\012" +
    "\245\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\032\016\073\017\136\020\067\021\133\022\255" +
    "\026\101\027\102\030\134\031\064\032\137\057\071\060" +
    "\027\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\013\260\014\016\001\001\000\006\015\221\066\222\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\011\263" +
    "\001\001\000\004\036\264\001\001\000\032\007\265\010" +
    "\036\013\034\014\016\023\017\024\030\037\037\046\024" +
    "\047\031\057\022\060\027\061\032\001\001\000\032\010" +
    "\216\012\266\013\034\014\016\023\017\024\030\037\037" +
    "\046\024\047\031\057\022\060\027\061\032\001\001\000" +
    "\002\001\001\000\010\033\271\040\270\066\272\001\001" +
    "\000\012\033\307\035\306\041\305\066\272\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\035\274\001\001" +
    "\000\022\017\053\021\063\030\051\031\055\032\061\034" +
    "\275\057\054\060\027\001\001\000\002\001\001\000\004" +
    "\011\277\001\001\000\004\036\300\001\001\000\032\007" +
    "\301\010\036\013\034\014\016\023\017\024\030\037\037" +
    "\046\024\047\031\057\022\060\027\061\032\001\001\000" +
    "\032\010\216\012\302\013\034\014\016\023\017\024\030" +
    "\037\037\046\024\047\031\057\022\060\027\061\032\001" +
    "\001\000\002\001\001\000\010\033\271\040\304\066\272" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\011\312" +
    "\001\001\000\004\035\313\001\001\000\032\007\314\010" +
    "\036\013\034\014\016\023\017\024\030\037\037\046\024" +
    "\047\031\057\022\060\027\061\032\001\001\000\032\010" +
    "\216\012\315\013\034\014\016\023\017\024\030\037\037" +
    "\046\024\047\031\057\022\060\027\061\032\001\001\000" +
    "\002\001\001\000\002\001\001\000\022\017\053\021\063" +
    "\030\051\031\055\032\061\034\321\057\054\060\027\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\011\323" +
    "\001\001\000\004\036\324\001\001\000\032\007\325\010" +
    "\036\013\034\014\016\023\017\024\030\037\037\046\024" +
    "\047\031\057\022\060\027\061\032\001\001\000\032\010" +
    "\216\012\326\013\034\014\016\023\017\024\030\037\037" +
    "\046\024\047\031\057\022\060\027\061\032\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\062\334\063\333\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\063\340\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\053\361" +
    "\054\360\001\001\000\004\004\346\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\011\352" +
    "\001\001\000\036\006\354\007\353\010\036\013\034\014" +
    "\016\023\017\024\030\037\037\046\024\047\031\057\022" +
    "\060\027\061\032\066\355\001\001\000\030\010\216\013" +
    "\034\014\016\023\017\024\030\037\037\046\024\047\031" +
    "\057\022\060\027\061\032\001\001\000\004\012\356\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



  private SymbolsTable symbolsTable;
  private BackTables backTables;
  private Lexico lexico;
  private GeneratorC3A codi3a;
  private GeneratorAssembler assembler;
  private String filename;
  private String filenamePath;

  private Stack<String> labelTrueStack;
  private Stack<String> labelFalseStack;

  public Parser(Lexico lexico, ComplexSymbolFactory sf){
    super(lexico, sf);
    this.lexico = lexico;
    this.symbolsTable = new SymbolsTable();
    this.backTables = new BackTables(symbolsTable);
    this.codi3a = new GeneratorC3A();
    this.assembler = new GeneratorAssembler(symbolsTable, backTables, codi3a, "Example");
    this.labelTrueStack = new Stack<String>();
    this.labelFalseStack = new Stack<String>();
  }

  public Parser(Lexico lexico, ComplexSymbolFactory sf, String filename){
      super(lexico, sf);
      this.lexico = lexico;
      this.filename = filename;
      this.symbolsTable = new SymbolsTable(filename);
      this.backTables = new BackTables(symbolsTable, filename);
      this.codi3a = new GeneratorC3A(filename);
      this.assembler = new GeneratorAssembler(symbolsTable, backTables, codi3a, filename);
      this.labelTrueStack = new Stack<String>();
      this.labelFalseStack = new Stack<String>();
      filenamePath = filename;
      int pos = filenamePath.lastIndexOf(".");
      if (pos > 0) {
          filenamePath = filenamePath.substring(0, pos);
      }
    }


  public void syntax_error(Symbol s) {
    try {
      ArrayList<Integer> expected = new ArrayList<Integer>(expected_token_ids());
      ArrayList<String> expected_names = new ArrayList<String>();

      for(Integer i : expected){
        expected_names.add(symbl_name_from_id(i));
      }

      Lexico.closeFile((s.left + 1), (s.right + 1));

      ComplexSymbol complexSymbol = (ComplexSymbol) s;

      throw new CompilerError(complexSymbol, expected_names, true, filenamePath);
    } catch (Exception e) {
		};
  }

  public void unrecovered_syntax_error(Symbol s){
    try {
      ArrayList<Integer> expected = new ArrayList<Integer>(expected_token_ids());
      ArrayList<String> expected_names = new ArrayList<String>();

      for(Integer i : expected){
        expected_names.add(symbl_name_from_id(i));
      }

      Lexico.closeFile((s.left + 1), (s.right + 1));

      ComplexSymbol complexSymbol = (ComplexSymbol) s;

      throw new CompilerError(complexSymbol, expected_names, false, filenamePath);
    } catch (Exception e) {
      SymTabError.closeFile();
      CompilerError.closeFiles();
		};
  }

  private void inicioTipos() {
    try{
      //init TUPLE type
      Type tuple_type = new Type(Tipo.dtype, TipoSubyacente.TS_TUPLE, 0);
      symbolsTable.add("tuple", tuple_type);

      //init NUMBER type
      Type number_type = new Type(Tipo.dtype, TipoSubyacente.TS_NUMBER, 16);
      symbolsTable.add("number", number_type);

      // init String type
      Type str_type = new Type(Tipo.dtype, TipoSubyacente.TS_STRING, 16);
      symbolsTable.add("string", str_type);

      //init BOOLEAN type
      Type bool_type = new Type(Tipo.dtype,TipoSubyacente.TS_BOOLEAN, 16);
      symbolsTable.add("boolean",bool_type);

      //init VOID type
      Type void_type = new Type(Tipo.dtype, TipoSubyacente.TS_NULL, 0);
      symbolsTable.add("void", void_type);
    }catch (SymTabError e){
      SymTabError.closeFile();
      CompilerError.closeFiles();
    }
  }



/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= STARTS EOF 
            {
              Object RESULT =null;
		Location start_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location start_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		Start start_val = (Start)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // STARTS ::= INIT declare_functions 
            {
              Start RESULT =null;
		
                              symbolsTable.closeSymbolsTableFiles();
                              backTables.guardarTablasBack();
                              codi3a.guardarC3Dir();
                              assembler.generateAssembler();
                              SymTabError.closeFile();
                              CompilerError.closeFiles();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("STARTS",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // INIT ::= 
            {
              Init RESULT =null;
		
                              inicioTipos();
                              RESULT = new Init();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INIT",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // declare_functions ::= define_function declare_functions 
            {
              DeclareFunctions RESULT =null;
		
                              RESULT = new DeclareFunctions();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declare_functions",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // declare_functions ::= main_s 
            {
              DeclareFunctions RESULT =null;
		
                              RESULT = new DeclareFunctions();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declare_functions",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // define_function ::= function_init LBRACE block_in function_instructions function_return block_out RBRACE 
            {
              DefineFunction RESULT =null;
		Location init_funcxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).xleft;
		Location init_funcxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).xright;
		FunctionInit init_func = (FunctionInit)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		Location ret_funcxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location ret_funcxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		FunctionReturn ret_func = (FunctionReturn)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
                              //Check function type and return type
                              if (init_func.getTipoSubyacente() != ret_func.getTipoSubyacente()) {
                                  String msg = "Mismatched return type. Expected: " + init_func.getTipoSubyacente() + 
                                                  ", but received: " + ret_func.getTipoSubyacente() + 
                                                  " from " + ret_funcxleft.getLine() + ":" + ret_funcxleft.getColumn() + 
                                                  " to " + ret_funcxright.getLine() + ":" + ret_funcxright.getColumn();

                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }

                              // NO RETURN
                              if (TipoSubyacente.TS_NULL == init_func.getTipoSubyacente()){
                                codi3a.generarC3A(Code.rtn,null,null,init_func.getFunId()); 
                              // RETURN
                              } else {
                                codi3a.generarC3A(Code.rtn,ret_func.getVarId(),null,init_func.getFunId());
                              }

                              RESULT = new DefineFunction();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("define_function",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // function_init ::= FUNC ID function_params RPAREN TWO_POINTS ID 
            {
              FunctionInit RESULT =null;
		Location fun_idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).xleft;
		Location fun_idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).xright;
		String fun_id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		Location params_funxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).xleft;
		Location params_funxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).xright;
		FunctionParams params_fun = (FunctionParams)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		Location type_idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location type_idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		String type_id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                
                                // Return type
                                Type return_tp = symbolsTable.get(type_id);
                                if (Tipo.dtype != return_tp.getTipo()) {
                                  String msg = "Invalid function declaration: incorrect type from " + 
                                  type_idxleft.getLine() + ":" + type_idxleft.getColumn() + 
                                  " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                // Comprobar que es boolean o number
                                if (TipoSubyacente.TS_STRING==return_tp.getTipoSubyacente()) {
                                  String msg = "Invalid return type: " + type_id + 
                                  ". Expected boolean or number from " + 
                                  type_idxleft.getLine() + ":" + type_idxleft.getColumn() + 
                                  " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                ArrayList<Parameter> parameters = params_fun.getParams();
                                TipoSubyacente subtipo = return_tp.getTipoSubyacente();
                                String bid = backTables.addProcedure(fun_id, parameters.size(), 0, subtipo);
                                Type fun_type = new Type(bid, Tipo.dfun, type_id);
                                symbolsTable.add(fun_id, fun_type);

                                // Add parameters
                                for (Parameter param : parameters) {
                                  Type param_tipo = param.getType();
                                  TipoSubyacente param_subtipo = symbolsTable.get(param.getType().getTypeName()).getTipoSubyacente();
                                  String p_backid = backTables.addVariable(param.getVarId(), param_subtipo, param.getSize(), true);
                                  param_tipo.setIdBack(p_backid);
                                  symbolsTable.addParam(fun_id, p_backid, param.getVarId(), param_tipo);
                                }

                                codi3a.generarC3A(Code.skip,null,null,bid);
                                codi3a.generarC3A(Code.pmb,null,null,bid);

                                RESULT = new FunctionInit(bid, subtipo);

                              } catch (SymTabError e) {
                                  String msg = e.getMessage() + " from " + 
                                  type_idxleft.getLine() + ":" + type_idxleft.getColumn() + 
                                  " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_init",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // function_params ::= function_w_params 
            {
              FunctionParams RESULT =null;
		Location parametersxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location parametersxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		FunctionWithParams parameters = (FunctionWithParams)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              RESULT = new FunctionParams(parameters.getParams());
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_params",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // function_params ::= LPAREN 
            {
              FunctionParams RESULT =null;
		
                              RESULT = new FunctionParams();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_params",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // function_w_params ::= function_w_params COMMA ID TWO_POINTS ID 
            {
              FunctionWithParams RESULT =null;
		Location prevxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).xleft;
		Location prevxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).xright;
		FunctionWithParams prev = (FunctionWithParams)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		Location idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location type_idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location type_idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		String type_id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                
                                // Parameter type
                                Type tipus = symbolsTable.get(type_id);
                                if (Tipo.dtype != tipus.getTipo()) {
                                  String msg = "Invalid parameter type from " + 
                                  idxleft.getLine() + ":" + idxleft.getColumn() + 
                                  " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();
                                }
                                
                                if (TipoSubyacente.TS_STRING == tipus.getTipoSubyacente()) {
                                  String msg = "Invalid parameter type: " + type_id + ". Expected boolean or number, found from " + 
                                  idxleft.getLine() + ":" + idxleft.getColumn() + 
                                  " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                Type p_tipo = new Type(Tipo.darg, type_id);
                                Parameter parameter = new Parameter(id, p_tipo, tipus.getSize());
                                RESULT = new FunctionWithParams(parameter, prev);

                              } catch (SymTabError e) {
                                String msg = e.getMessage() + " from " + 
                                type_idxleft.getLine() + ":" + type_idxleft.getColumn() + 
                                " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_w_params",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // function_w_params ::= LPAREN ID TWO_POINTS ID 
            {
              FunctionWithParams RESULT =null;
		Location idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location type_idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location type_idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		String type_id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                
                                // Parameter type
                                Type tipus = symbolsTable.get(type_id);
                                if (Tipo.dtype != tipus.getTipo()) {
                                  String msg = "Invalid parameter type from " + 
                                  idxleft.getLine() + ":" + idxleft.getColumn() + 
                                  " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }
                                if (TipoSubyacente.TS_STRING == tipus.getTipoSubyacente()) {
                                  String msg = "Invalid parameter type: " + type_id + ". Expected boolean or number, found from " + 
                                  idxleft.getLine() + ":" + idxleft.getColumn() + 
                                  " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                Type p_tipo = new Type(Tipo.darg, type_id);
                                Parameter parameter = new Parameter(id, p_tipo, tipus.getSize());
                                RESULT = new FunctionWithParams(parameter);

                              } catch (SymTabError e) {
                                String msg = e.getMessage() + " from " + 
                                type_idxleft.getLine() + ":" + type_idxleft.getColumn() + 
                                " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_w_params",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // function_instructions ::= instructions 
            {
              FunctionInstructions RESULT =null;
		
                              RESULT = new FunctionInstructions();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_instructions",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // function_instructions ::= 
            {
              FunctionInstructions RESULT =null;
		
                              RESULT = new FunctionInstructions();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_instructions",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // function_return ::= RETURN value SEMICOLON 
            {
              FunctionReturn RESULT =null;
		Location valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		Value val = (Value)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                              try {
                                // Literal
                                TipoSubyacente subtipo = null;
                                if (Tipo.dnull == val.getTipo()) {
                                  subtipo = val.getTipoSubyacente();
                                }

                                // Var
                                if (Tipo.dnull != val.getTipo()) {
                                  Type tipo = symbolsTable.get(val.getTypeName());
                                  subtipo = tipo.getTipoSubyacente();
                                }

                                RESULT = new FunctionReturn(val.getVarId(), subtipo);

                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_return",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // function_return ::= EMPTY 
            {
              FunctionReturn RESULT =null;
		
                              RESULT = new FunctionReturn();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("function_return",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // main_s ::= FUNC MAIN m_main LPAREN RPAREN LBRACE block_in main_instructions block_out RBRACE 
            {
              MainS RESULT =null;
		
                              codi3a.generarC3A(Code.rtn,null,null,"PROC_main");
                              RESULT = new MainS();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("main_s",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // m_main ::= 
            {
              MainLabel RESULT =null;
		
                              String bid = backTables.addMain();
                              Type tipofunc = new Type(bid, Tipo.dfun, null);
                              symbolsTable.add("main", tipofunc);
                              codi3a.generarC3A(Code.skip,null,null,"main");
                              codi3a.generarC3A(Code.pmb,null,null,bid);

                              RESULT = new MainLabel();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("m_main",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // main_instructions ::= instructions 
            {
              MainInstructions RESULT =null;
		
                              RESULT = new MainInstructions();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("main_instructions",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // main_instructions ::= EMPTY 
            {
              MainInstructions RESULT =null;
		
                              RESULT = new MainInstructions();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("main_instructions",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // instructions ::= instructions instruction 
            {
              Instructions RESULT =null;
		
                              RESULT = new Instructions();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instructions",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // instructions ::= instruction 
            {
              Instructions RESULT =null;
		
                              RESULT = new Instructions();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instructions",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // instruction ::= declarations SEMICOLON 
            {
              Instruction RESULT =null;
		
                              RESULT = new Instruction();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // instruction ::= tuple_declaration SEMICOLON 
            {
              Instruction RESULT =null;
		
                              RESULT = new Instruction();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // instruction ::= instruction_if 
            {
              Instruction RESULT =null;
		
                              RESULT = new Instruction();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // instruction ::= instruction_while 
            {
              Instruction RESULT =null;
		
                              RESULT = new Instruction();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // instruction ::= instruction_for 
            {
              Instruction RESULT =null;
		
                              RESULT = new Instruction();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // instruction ::= operator_assig SEMICOLON 
            {
              Instruction RESULT =null;
		
                              RESULT = new Instruction();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // instruction ::= instruction_out SEMICOLON 
            {
              Instruction RESULT =null;
		
                              RESULT = new Instruction();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // instruction ::= call_function SEMICOLON 
            {
              Instruction RESULT =null;
		
                              RESULT = new Instruction();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // block_in ::= 
            {
              BlockIn RESULT =null;
		
                              symbolsTable.enterBlock();
                              RESULT = new BlockIn();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("block_in",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // block_out ::= 
            {
              BlockOut RESULT =null;
		
                              try {
                                symbolsTable.leaveBlock();
                                RESULT = new BlockOut();
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("block_out",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // declarations ::= ID COMMA declarations 
            {
              Declarations RESULT =null;
		Location id_varxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location id_varxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		String id_var = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location declarationsxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location declarationsxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Declarations declarations = (Declarations)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                Type tipo = declarations.getType();
                                String bid;
                                if (TipoSubyacente.TS_STRING == tipo.getTipoSubyacente()) {
                                  String val = declarations.getValue();
                                  bid = backTables.addStringVariable(id_var, tipo.getSize(), val);
                                } else {
                                  bid = backTables.addVariable(id_var, tipo.getTipoSubyacente(), tipo.getSize(), false);
                                }

                                tipo.setIdBack(bid);
                                symbolsTable.add(id_var, tipo);
                                codi3a.generarC3A(Code.copy, declarations.getVarId(), null, bid);

                                RESULT = declarations;

                              } catch (SymTabError e) {
                                String msg = e.getMessage() + " from " + 
                                id_varxleft.getLine() + ":" + id_varxleft.getColumn() + 
                                " to " + id_varxright.getLine() + ":" + id_varxright.getColumn();

                                throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declarations",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // declarations ::= declaration 
            {
              Declarations RESULT =null;
		Location declarationxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location declarationxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Declarations declaration = (Declarations)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              RESULT = declaration;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declarations",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // tuple_declaration ::= STRUCT LBRACE field_list RBRACE ID 
            {
              TupleDeclaration RESULT =null;
		Location field_listxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location field_listxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		FieldList field_list = (FieldList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location var_idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location var_idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		String var_id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                            Type type = symbolsTable.get("tuple");
                            type.setSize(field_list.getSize());
                            type.setTupleTypes(field_list.getTypes());
                            symbolsTable.add(var_id, type);
                            RESULT = new TupleDeclaration(var_id, field_list, field_list.getSize());
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("tuple_declaration",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // field_list ::= field_list SEMICOLON tuple_field 
            {
              FieldList RESULT =null;
		Location field_listxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location field_listxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		FieldList field_list = (FieldList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location fieldxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location fieldxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		TupleField field = (TupleField)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                            field_list.addField(field);
                            RESULT = field_list;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("field_list",48, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // field_list ::= tuple_field 
            {
              FieldList RESULT =null;
		Location fieldxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location fieldxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		TupleField field = (TupleField)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                            ArrayList<TupleField> tupleFields = new ArrayList<>();
                            tupleFields.add(field);
                            RESULT = new FieldList(tupleFields);
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("field_list",48, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // tuple_field ::= ID TWO_POINTS ID 
            {
              TupleField RESULT =null;
		Location id_varxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location id_varxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		String id_var = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location type_idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location type_idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		String type_id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                            Type type = symbolsTable.get(type_id);
                            if (type == null || type.getTipo() != Tipo.dtype) {
                              String from = type_idxleft.getLine() + ":" + type_idxleft.getColumn();
                              String to = type_idxright.getLine() + ":" + type_idxright.getColumn();
                              String msg = "Invalid type" + " from "+from+" to "+to;
                              throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                            }

                            String backId = backTables.addVariable(id_var, type.getTipoSubyacente(), type.getSize(), false);
                            type.setIdBack(backId);
                            symbolsTable.add(id_var, type);

                            RESULT = new TupleField(id_var, type);
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("tuple_field",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // declaration ::= ID constant TWO_POINTS ID OP_ASSIG value 
            {
              Declarations RESULT =null;
		Location id_varxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).xleft;
		Location id_varxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).xright;
		String id_var = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		Location constantxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).xleft;
		Location constantxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).xright;
		Const constant = (Const)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		Location type_idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location type_idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		String type_id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location valuexleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location valuexright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Value value = (Value)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {

                                boolean isConst = constant != null ? constant.getIsConst() : false;

                                Type type = symbolsTable.get(type_id);

                                if (type == null || type.getTipo() != Tipo.dtype) {
                                  String msg = "Invalid type from " + 
                                  type_idxleft.getLine() + ":" + type_idxleft.getColumn() + 
                                  " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                if (type.getTipoSubyacente() != TipoSubyacente.TS_BOOLEAN
                                  && type.getTipoSubyacente() != TipoSubyacente.TS_NUMBER
                                  && type.getTipoSubyacente() != TipoSubyacente.TS_STRING) {
                                    String msg = "Declaration: Invalid subjacent type from " + 
                                    type_idxleft.getLine() + ":" + type_idxleft.getColumn() + 
                                    " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                    throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                //IF LITERALL (type = null) CHECK SUBJACENT Tipo
                                if (value.getTipo() == Tipo.dnull && type.getTipoSubyacente() != value.getTipoSubyacente()) {
                                  String msg = "Value and type must match the same subjacent type from " + 
                                                  type_idxleft.getLine() + ":" + type_idxleft.getColumn() + 
                                                  " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                if (value.getTipo() != Tipo.dnull && !value.getTypeName().equals(type_id)) {
                                  String msg = "Value and type must match the same subjacent type, from " + 
                                  type_idxleft.getLine() + ":" + type_idxleft.getColumn() + 
                                  " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                Type var_type;

                                if (isConst) {
                                  var_type = new Type(Tipo.dconst, type_id, value.getValue());
                                } else {
                                  var_type = new Type(Tipo.dvar, type_id);
                                }

                                int size = type.getSize();
                                if (value.getIsString()) {
                                  size = value.getStringSize();
                                }

                                String var_id;
                                if (type.getTipoSubyacente() == TipoSubyacente.TS_STRING) {
                                  String str_value = (String) value.getValue();
                                  var_id = backTables.addStringVariable(id_var, type.getSize(), str_value);
                                } else {
                                  var_id = backTables.addVariable(id_var, type.getTipoSubyacente(), type.getSize(), false);
                                }

                                var_type.setIdBack(var_id);

                                String val_id = value.getVarId();
                                symbolsTable.add(id_var, var_type);

                                Declarations symDcls;
                                if (value.getIsString()) {
                                  symDcls = new Declarations(val_id, var_type, (String) value.getValue());
                                } else {
                                  symDcls = new Declarations(val_id, var_type);
                                }

                                if (type.getTipoSubyacente() != TipoSubyacente.TS_STRING) {
                                  codi3a.generarC3A(Code.copy,val_id,null,var_id);
                                }

                                RESULT = symDcls;

                              } catch(SymTabError e) {
                                String msg = e.getMessage() + " from " + 
                                id_varxleft.getLine() + ":" + id_varxleft.getColumn() + 
                                " to " + id_varxright.getLine() + ":" + id_varxright.getColumn();

                                throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaration",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // declaration ::= ID constant TWO_POINTS ID OP_ASSIG tuple_value 
            {
              Declarations RESULT =null;
		Location id_varxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).xleft;
		Location id_varxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).xright;
		String id_var = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		Location type_idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location type_idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		String type_id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location tuple_valuexleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location tuple_valuexright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		TupleValues tuple_value = (TupleValues)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                            Type type = symbolsTable.get(type_id);

                            if (type == null || type.getTipo() != Tipo.dtype) {
                              String msg = "Invalid type from " + 
                              type_idxleft.getLine() + ":" + type_idxleft.getColumn() + 
                              " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                              throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                            }

                            if (type.getTipoSubyacente() != TipoSubyacente.TS_TUPLE) {
                                String msg = "Declaration: Invalid subjacent type from " + 
                                type_idxleft.getLine() + ":" + type_idxleft.getColumn() + 
                                " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                            }

                            if (type.getTupleTypes().size() != tuple_value.getValues().size()) {
                                String msg = "Tuple Declaration: Invalid number of values from " + 
                                type_idxleft.getLine() + ":" + type_idxleft.getColumn() + 
                                " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                            }

                            for (int i = 0; i < tuple_value.getValues().size(); i++) {
                                if (type.getTupleTypes().get(i).getTipoSubyacente() != tuple_value.getValues().get(i).getTipoSubyacente()) {
                                    String msg = "TUPLE_DECLARATION: Invalid subjacent type of value from " + 
                                    type_idxleft.getLine() + ":" + type_idxleft.getColumn() + 
                                    " to " + type_idxright.getLine() + ":" + type_idxright.getColumn();

                                    throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }
                            }

                            for (int i = 0; i < tuple_value.getValues().size(); i++) {
                                var value = tuple_value.getValues().get(i);
                                var tipo = type.getTupleTypes().get(i);
                                codi3a.generarC3A(Code.copy,value.getVarId(),null,tipo.getBackendId());
                            }

                            backTables.addVariable(id_var, type.getTipoSubyacente(), type.getSize(), false);

                            RESULT = new Declarations();

                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declaration",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // constant ::= CONSTANT 
            {
              Const RESULT =null;
		
                              RESULT = new Const(true);
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constant",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // constant ::= EMPTY 
            {
              Const RESULT =null;
		
                              RESULT = new Const(false);
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("constant",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // operator_assig ::= ID OP_ASSIG value 
            {
              Assignation RESULT =null;
		Location var_idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location var_idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		String var_id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location valuexleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location valuexright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Value value = (Value)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                   Type tipo = symbolsTable.get(var_id);
                                   String idtipo = tipo.getTypeName();

                                   if (Tipo.dconst == tipo.getTipo()) {
                                      String msg = "Can't assign a value to a constant, from " + 
                                      var_idxleft.getLine() + ":" + var_idxleft.getColumn() + 
                                      " to " + valuexright.getLine() + ":" + valuexright.getColumn();

                                       throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                   }

                                   //If literal (type = null) check subjacent
                                   if (Tipo.dnull == value.getTipo() && tipo.getTipoSubyacente() == value.getTipoSubyacente()) {
                                      String msg = "Value and type must match the same subjacent type from " + 
                                      var_idxleft.getLine() + ":" + var_idxleft.getColumn() + 
                                      " to " + valuexright.getLine() + ":" + valuexright.getColumn();

                                       throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                   }

                                   if (Tipo.dnull != value.getTipo() && !value.getTypeName().equals(idtipo)) {
                                      String msg = "Value type and type_id must be the same type" + 
                                                      " from " + var_idxleft.getLine() + ":" + var_idxleft.getColumn() + 
                                                      " to " + valuexright.getLine() + ":" + valuexright.getColumn();
                                       throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                   }

                                   codi3a.generarC3A(Code.copy,value.getVarId(),null,tipo.getBackendId());

                                   RESULT = new Assignation();
                              } catch (SymTabError e) {
                                  String msg = e.getMessage() + 
                                  " from " + var_idxleft.getLine() + ":" + var_idxleft.getColumn() + 
                                  " to " + var_idxright.getLine() + ":" + var_idxright.getColumn();
                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("operator_assig",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // arith_op ::= OP_ARITHMETICAL_B 
            {
              ArithmeticOperator RESULT =null;
		Location opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		String op = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new ArithmeticOperator(op); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arith_op",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // arith_op ::= OP_ARITHMETICAL_C 
            {
              ArithmeticOperator RESULT =null;
		Location opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		String op = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new ArithmeticOperator(op); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arith_op",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // arithmetical_operation ::= arithmetical_value arith_op arithmetical_value 
            {
              ArithmeticOperation RESULT =null;
		Location ath_val1xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location ath_val1xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		ArithmeticValue ath_val1 = (ArithmeticValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		ArithmeticOperator op = (ArithmeticOperator)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		Location ath_val2xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location ath_val2xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		ArithmeticValue ath_val2 = (ArithmeticValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                ArithmeticOperation sym;
                                boolean allConst = ath_val1.getIsConst() && ath_val2.getIsConst();

                                Code op_code;

                                switch (op.getOperator()) {
                                  case "+" :
                                    op_code = Code.add;
                                    break;
                                  case "-" :
                                    op_code = Code.sub;
                                    break;
                                  case "*" :
                                    op_code = Code.prod;
                                    break;
                                  case "/" :
                                    op_code = Code.div;
                                    break;
                                  case "%" :
                                    op_code = Code.mod;
                                    break;
                                  default :
                                    String msg = "Invalid arithmetic operator from " + 
                                    opxleft.getLine() + ":" + opxleft.getColumn() + 
                                    " to " + opxright.getLine() + ":" + opxright.getColumn();
                                    throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                Integer value = null;
                                if (allConst) {
                                  Integer val1 = (Integer) ath_val1.getValue();
                                  Integer val2 = (Integer) ath_val2.getValue();

                                  switch (op.getOperator()) {
                                    case "+" :
                                      value = val1 + val2;
                                      break;
                                    case "-" :
                                      value = val1 - val2;
                                      break;
                                    case "*" :
                                      value = val1 * val2;
                                      break;
                                    case "/" :
                                      if (val2 == 0) {
                                        String msg = "Can not divide by zero (0)" + 
                                        " from " + ath_val2xleft.getLine() + ":" + ath_val2xleft.getColumn() + 
                                        " to " + ath_val2xright.getLine() + ":" + ath_val2xright.getColumn();
                                        throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                      }
                                      value = val1 / val2;
                                      break;
                                    case "%" :
                                      value = val1 % val2;
                                      break;
                                  }
                                }

                                Type tiponumero = symbolsTable.get("number");
                                String id_Var = backTables.addTempVar(tiponumero.getSize(), tiponumero.getTipoSubyacente());
                                codi3a.generarC3A(op_code, ath_val1.getVarId(), ath_val2.getVarId(), id_Var);

                                if(allConst){
                                  sym = new ArithmeticOperation(id_Var, value);
                                }
                                else{
                                  sym = new ArithmeticOperation(id_Var);
                                }

                                RESULT = sym;
                              } catch(SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arithmetical_operation",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // arithmetical_operation ::= OP_ARITHMETICAL_B LPAREN arithmetical_operation RPAREN 
            {
              ArithmeticOperation RESULT =null;
		Location opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).xleft;
		Location opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).xright;
		String op = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		Location arith_opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location arith_opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		ArithmeticOperation arith_op = (ArithmeticOperation)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                              try {
                                ArithmeticOperation sym = arith_op;
                                if (op.equals("-")) {
                                  Type tiponumero = symbolsTable.get("number");
                                  String id_Var = backTables.addTempVar(tiponumero.getSize(),  tiponumero.getTipoSubyacente());
 
                                  if (arith_op.getIsConst()) {
                                    Integer value = - arith_op.getValue().intValue();
                                    sym = new ArithmeticOperation(arith_op.getVarId(), value);
                                  } else {
                                    sym = new ArithmeticOperation(id_Var);
                                  }

                                  codi3a.generarC3A(Code.neg,arith_op.getVarId(),null,id_Var);
                                }

                                RESULT = sym;
                              } catch(SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arithmetical_operation",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // arithmetical_operation ::= LPAREN arithmetical_operation RPAREN 
            {
              ArithmeticOperation RESULT =null;
		Location arith_opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location arith_opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		ArithmeticOperation arith_op = (ArithmeticOperation)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                              RESULT = arith_op;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arithmetical_operation",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // number_value ::= NUMBER 
            {
              NumericValue RESULT =null;
		Location n_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location n_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		String n_val = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              Integer val = Integer.valueOf(n_val);
                              RESULT = new NumericValue(val);
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("number_value",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // number_value ::= LPAREN number_value RPAREN 
            {
              NumericValue RESULT =null;
		Location n_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location n_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		NumericValue n_val = (NumericValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                              RESULT = n_val;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("number_value",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // number_value ::= OP_ARITHMETICAL_B number_value 
            {
              NumericValue RESULT =null;
		Location opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		String op = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		Location n_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location n_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		NumericValue n_val = (NumericValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              NumericValue sym = n_val;
                              if (op.equals("-")) {
                                Integer value = - n_val.getValue().intValue();
                                sym = new NumericValue(value);
                              }

                              RESULT = sym;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("number_value",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // arithmetical_value ::= number_value 
            {
              ArithmeticValue RESULT =null;
		Location n_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location n_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		NumericValue n_val = (NumericValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                            try {
                              Integer val = n_val.getValue();
                              Type tiponumero = symbolsTable.get("number");
                              String idVar = backTables.addTempVar(tiponumero.getSize(),  tiponumero.getTipoSubyacente());
                              codi3a.generarC3A(Code.copy, Integer.toString(val), null, idVar);

                              RESULT = new ArithmeticValue(idVar, val);
                            } catch(SymTabError e) {
                              throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                            }
                          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arithmetical_value",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // arithmetical_value ::= id_value 
            {
              ArithmeticValue RESULT =null;
		Location id_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location id_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Identifier id_val = (Identifier)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                            try {

                              Tipo m_v_tipo = id_val.getTipo();
                              if (Tipo.darg != m_v_tipo && Tipo.dconst != m_v_tipo && Tipo.dvar != m_v_tipo) {
                                String msg = "Invalid arithmetic value type" + 
                                " from " + id_valxleft.getLine() + ":" + id_valxleft.getColumn() + 
                                " to " + id_valxright.getLine() + ":" + id_valxright.getColumn();
                                throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }

                              Type var_dtype = symbolsTable.get(id_val.getTypeName());

                              if (TipoSubyacente.TS_NUMBER != var_dtype.getTipoSubyacente()) {
                                String msg = "Arithmetic Value: Invalid subjacent type" + 
                                                " from " + id_valxleft.getLine() + ":" + id_valxleft.getColumn() + 
                                                " to " + id_valxright.getLine() + ":" + id_valxright.getColumn();
                                throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }

                              ArithmeticValue sym;
                              String idVar = id_val.getId();
                              if (Tipo.dconst == m_v_tipo) {
                                Integer val = (Integer) id_val.getValue();
                                sym = new ArithmeticValue(idVar, val);
                              } else {
                                sym = new ArithmeticValue(idVar);
                              }

                              RESULT = sym;
                            } catch(SymTabError e) {
                              throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                            }
                          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arithmetical_value",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // arithmetical_value ::= arithmetical_operation 
            {
              ArithmeticValue RESULT =null;
		Location arith_opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location arith_opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		ArithmeticOperation arith_op = (ArithmeticOperation)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                            ArithmeticValue sym;
                            if (arith_op.getIsConst()) {
                              sym = new ArithmeticValue(arith_op.getVarId(), arith_op.getValue());
                            } else {
                              sym = new ArithmeticValue(arith_op.getVarId());
                            }

                            RESULT = sym;
                          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arithmetical_value",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // arithmetical_value ::= call_function 
            {
              ArithmeticValue RESULT =null;
		Location call_fnxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location call_fnxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		CallFunction call_fn = (CallFunction)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                            try {
                              Type tipofunc = symbolsTable.get(call_fn.getFunctionId());
                              Type tipodef = symbolsTable.get(tipofunc.getTypeName());

                              if (tipodef.getTipoSubyacente() != TipoSubyacente.TS_NUMBER) {
                                String msg = "Invalid function call " + call_fn.getFunctionId() + 
                                                " with return type " + tipodef.getTipoSubyacente() + 
                                                ". Expected :" + TipoSubyacente.TS_NUMBER + 
                                                " from " + call_fnxleft.getLine() + ":" + call_fnxleft.getColumn() + 
                                                " to " + call_fnxright.getLine() + ":" + call_fnxright.getColumn();
                                throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }

                              String var_id = backTables.addTempVar(tipodef.getSize(), tipodef.getTipoSubyacente());

                              codi3a.generarC3A(Code.copy,"return",call_fn.getBackendId(),var_id);

                              RESULT = new ArithmeticValue(var_id);
                            } catch (SymTabError e) {
                              String msg = e.getMessage() + 
                              " from " + call_fnxleft.getLine() + ":" + call_fnxleft.getColumn() + 
                              " to " + call_fnxright.getLine() + ":" + call_fnxright.getColumn();
                              throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                            }
                          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arithmetical_value",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // arithmetical_value ::= OP_ARITHMETICAL_B call_function 
            {
              ArithmeticValue RESULT =null;
		Location opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		String op = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		Location call_fnxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location call_fnxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		CallFunction call_fn = (CallFunction)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                            try {
                              Type tipofunc = symbolsTable.get(call_fn.getFunctionId());
                              Type tipodef = symbolsTable.get(tipofunc.getTypeName());

                              if (tipodef.getTipoSubyacente() != TipoSubyacente.TS_NUMBER) {
                                String msg = "Invalid function call " + call_fn.getFunctionId() + 
                                                " with return type " + tipodef.getTipoSubyacente() + 
                                                ". Expected :" + TipoSubyacente.TS_NUMBER + 
                                                " from " + call_fnxleft.getLine() + ":" + call_fnxleft.getColumn() + 
                                                " to " + call_fnxright.getLine() + ":" + call_fnxright.getColumn();
                                throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }

                              String idVar = backTables.addTempVar(tipodef.getSize(), tipodef.getTipoSubyacente());

                              codi3a.generarC3A(Code.copy,"return",call_fn.getBackendId(),idVar);

                              if (op.equals("-")) {
                                codi3a.generarC3A(Code.neg,idVar,null,idVar);
                              }

                              RESULT = new ArithmeticValue(idVar);
                            } catch (SymTabError e) {
                              String msg = e.getMessage() + 
                              " from " + call_fnxleft.getLine() + ":" + call_fnxleft.getColumn() + 
                              " to " + call_fnxright.getLine() + ":" + call_fnxright.getColumn();
                              throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                            }
                          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("arithmetical_value",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // id_value ::= ID 
            {
              Identifier RESULT =null;
		Location id_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location id_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		String id_val = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                Type tipo = symbolsTable.get(id_val);
                                String idVar = tipo.getBackendId();
                                Identifier sym = new Identifier(idVar, tipo.getTipo(), tipo.getTypeName());
                                if (Tipo.dconst == tipo.getTipo()) {
                                  sym = new Identifier(idVar, tipo.getTipo(), tipo.getTypeName(), tipo.getValue());
                                }
                                RESULT = sym;
                              } catch (SymTabError e) {
                                String msg = e.getMessage() + 
                                " from " + id_valxleft.getLine() + ":" + id_valxleft.getColumn() + 
                                " to " + id_valxright.getLine() + ":" + id_valxright.getColumn();
                                throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("id_value",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // id_value ::= LPAREN id_value RPAREN 
            {
              Identifier RESULT =null;
		Location id_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location id_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		Identifier id_val = (Identifier)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                              RESULT = id_val;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("id_value",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // id_value ::= OP_LOGICAL_NOT id_value 
            {
              Identifier RESULT =null;
		Location opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		String op = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		Location id_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location id_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Identifier id_val = (Identifier)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {

                                Identifier sym;
                                TipoSubyacente subtipo = symbolsTable.get(id_val.getTypeName()).getTipoSubyacente();

                                if (TipoSubyacente.TS_BOOLEAN != subtipo) {
                                  String msg = "Invalid unary operator " + op + 
                                                  " for type " + subtipo + 
                                                  " from " + opxleft.getLine() + ":" + opxleft.getColumn() + 
                                                  " to " + opxright.getLine() + ":" + opxright.getColumn();
                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                Type booleantipo = symbolsTable.get("boolean");
                                String idVar = backTables.addTempVar(booleantipo.getSize(),  booleantipo.getTipoSubyacente());

                                codi3a.generarC3A(Code.not,id_val.getId(),null,idVar);

                                if (Tipo.dconst == id_val.getTipo()) {
                                  Boolean val = !((Boolean) id_val.getValue()).booleanValue();
                                  sym = new Identifier(idVar, id_val.getTipo(), id_val.getTypeName(), val);
                                } else {
                                  sym = new Identifier(idVar, id_val.getTipo(), id_val.getTypeName());
                                }
                                RESULT = sym;
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("id_value",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // id_value ::= OP_ARITHMETICAL_B id_value 
            {
              Identifier RESULT =null;
		Location opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		String op = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		Location id_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location id_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Identifier id_val = (Identifier)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                Identifier sym = id_val;
                                TipoSubyacente subtipo = symbolsTable.get(id_val.getTypeName()).getTipoSubyacente();

                                if (TipoSubyacente.TS_BOOLEAN != subtipo) {
                                  String msg = "Invalid unary operator " + op + 
                                                  " for type " + subtipo + 
                                                  " from " + opxleft.getLine() + ":" + opxleft.getColumn() + 
                                                  " to " + opxright.getLine() + ":" + opxright.getColumn();
                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                if (op.equals("-")) {
                                  Type type_number = symbolsTable.get("number");
                                  String idVar = backTables.addTempVar(type_number.getSize(),  type_number.getTipoSubyacente());

                                  codi3a.generarC3A(Code.neg,id_val.getId(),null,idVar);

                                  if (Tipo.dconst == id_val.getTipo()) {
                                    Integer val = -((Integer) id_val.getValue()).intValue();
                                    sym = new Identifier(idVar, id_val.getTipo(), id_val.getTypeName(), val);
                                  } else {
                                    sym = new Identifier(idVar, id_val.getTipo(), id_val.getTypeName());
                                  }
                                }
                                RESULT = sym;
                              } catch(SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("id_value",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // string_value ::= STRING 
            {
              StringValue RESULT =null;
		Location string_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location string_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		String string_val = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              RESULT = new StringValue(string_val);
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("string_value",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // string_value ::= LPAREN string_value RPAREN 
            {
              StringValue RESULT =null;
		Location string_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location string_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		StringValue string_val = (StringValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                              RESULT = string_val;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("string_value",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // value ::= id_value 
            {
              Value RESULT =null;
		Location id_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location id_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Identifier id_val = (Identifier)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              Value sym;
                              String idVar = id_val.getId();

                              if (id_val.getTipo() == Tipo.dconst) {
                                sym = new Value(idVar, id_val.getTipo(), id_val.getTypeName(), id_val.getValue());
                              } else {
                                sym = new Value(idVar, id_val.getTipo(), id_val.getTypeName());
                              }
                              RESULT = sym;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("value",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // value ::= string_value 
            {
              Value RESULT =null;
		Location str_valuexleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location str_valuexright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		StringValue str_value = (StringValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                Value sym;
                                String val = str_value.getString().replace("\"", "");
                                Type tipostring = symbolsTable.get("string");

                                if (val.length() > 1000) {
                                  String msg = "String must be shorter than 1000 characters " + 
                                                  " from " + str_valuexleft.getLine() + ":" + str_valuexleft.getColumn() + 
                                                  " to " + str_valuexright.getLine() + ":" + str_valuexright.getColumn();
                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                // String size
                                int stringSize = val.length() * tipostring.getSize();
                                sym = new Value(val, stringSize);
                                RESULT = sym;
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("value",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // value ::= boolean_value 
            {
              Value RESULT =null;
		Location bool_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location bool_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		BooleanValue bool_val = (BooleanValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                Boolean val = bool_val.getValue();
                                Type type_bool = symbolsTable.get("boolean");
                                String idVar = backTables.addTempVar(type_bool.getSize(), type_bool.getTipoSubyacente());
                                codi3a.generarC3A(Code.copy,val.toString(),null,idVar);
                                RESULT = new Value(idVar, TipoSubyacente.TS_BOOLEAN, val);
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("value",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // value ::= number_value 
            {
              Value RESULT =null;
		Location n_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location n_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		NumericValue n_val = (NumericValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try{
                                Integer val = n_val.getValue();
                                Type tiponumero = symbolsTable.get("number");
                                String idVar = backTables.addTempVar(tiponumero.getSize(), tiponumero.getTipoSubyacente());
                                codi3a.generarC3A(Code.copy,Integer.toString(val),null,idVar);
                                RESULT = new Value(idVar, TipoSubyacente.TS_NUMBER, val);
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("value",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // value ::= value_comparison 
            {
              Value RESULT =null;
		Location comp_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location comp_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		ValuesComparison comp_val = (ValuesComparison)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              Value sym;
                              String id = comp_val.getVarId();
                              if (comp_val.getIsConst()) {
                                Boolean val = comp_val.getValue();
                                sym = new Value(id, TipoSubyacente.TS_BOOLEAN, val);
                              } else {
                                sym = new Value(id, TipoSubyacente.TS_BOOLEAN);
                              }
                              RESULT = sym;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("value",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // value ::= OP_LOGICAL_NOT value_comparison 
            {
              Value RESULT =null;
		Location comp_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location comp_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		ValuesComparison comp_val = (ValuesComparison)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                Value sym;
                                Type tipobool = symbolsTable.get("boolean");
                                String idVar = backTables.addTempVar(tipobool.getSize(), tipobool.getTipoSubyacente());

                                codi3a.generarC3A(Code.not,comp_val.getVarId(),null,idVar);

                                if (comp_val.getIsConst()) {
                                  Boolean val = ! comp_val.getValue().booleanValue();
                                  sym = new Value(idVar, TipoSubyacente.TS_BOOLEAN, val);
                                } else {
                                  sym = new Value(idVar, TipoSubyacente.TS_BOOLEAN);
                                }
                                RESULT = sym;
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("value",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // value ::= arithmetical_operation 
            {
              Value RESULT =null;
		Location arith_opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location arith_opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		ArithmeticOperation arith_op = (ArithmeticOperation)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              Value sym;
                              String idVar = arith_op.getVarId();
                              if (arith_op.getIsConst()) {
                                sym = new Value(idVar, TipoSubyacente.TS_NUMBER, arith_op.getValue());
                              } else {
                                sym = new Value(idVar, TipoSubyacente.TS_NUMBER);
                              }
                              RESULT = sym;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("value",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // value ::= boolean_operation 
            {
              Value RESULT =null;
		Location bool_opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location bool_opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		BooleanOperator bool_op = (BooleanOperator)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              Value sym;
                              String idVar = new String(bool_op.getVarId());
                              if (bool_op.getIsConst()) {
                                sym = new Value(idVar, TipoSubyacente.TS_BOOLEAN, bool_op.getValue());
                              } else {
                                sym = new Value(idVar, TipoSubyacente.TS_BOOLEAN);
                              }

                              RESULT = sym;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("value",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // value ::= call_function 
            {
              Value RESULT =null;
		Location call_fnxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location call_fnxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		CallFunction call_fn = (CallFunction)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                Type tipofunc = symbolsTable.get(call_fn.getFunctionId());
                                Type tipodef = symbolsTable.get(tipofunc.getTypeName());

                                if (TipoSubyacente.TS_NULL == tipodef.getTipoSubyacente()) {
                                  String msg = "Function call : " + call_fn.getFunctionId() + 
                                  " does not return any value" + 
                                  " from " + call_fnxleft.getLine() + ":" + call_fnxleft.getColumn() + 
                                  " to " + call_fnxright.getLine() + ":" + call_fnxright.getColumn();
                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                String idVar = backTables.addTempVar(tipodef.getSize(), tipodef.getTipoSubyacente());
                                codi3a.generarC3A(Code.copy,"return",call_fn.getBackendId(),idVar);
                                RESULT = new Value(idVar, Tipo.dfun, tipofunc.getTypeName());
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("value",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // value ::= READ LPAREN RPAREN 
            {
              Value RESULT =null;
		
                              try {
                                Type tiponumero = symbolsTable.get("number");
                                String idVar = backTables.addTempVar(tiponumero.getSize(), tiponumero.getTipoSubyacente());
                                codi3a.generarC3A(Code.read,null,null,idVar);
                                RESULT = new Value(idVar, tiponumero.getTipoSubyacente());
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("value",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // tuple_value ::= LBRACKET tuple_values RBRACKET 
            {
              TupleValues RESULT =null;
		Location tuple_valuesxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location tuple_valuesxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		TupleValues tuple_values = (TupleValues)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                            RESULT = tuple_values;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("tuple_value",50, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // tuple_values ::= tuple_values COMMA value 
            {
              TupleValues RESULT =null;
		Location valuesxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location valuesxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		TupleValues values = (TupleValues)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location valuexleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location valuexright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Value value = (Value)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                            values.addValue(value);
                            RESULT = values;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("tuple_values",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // tuple_values ::= value 
            {
              TupleValues RESULT =null;
		Location valuexleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location valuexright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Value value = (Value)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                            RESULT = new TupleValues(new ArrayList<>(List.of(value)));
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("tuple_values",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // boolean_operation ::= boolean_op_value OP_LOGICAL boolean_op_value 
            {
              BooleanOperator RESULT =null;
		Location bool_val1xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location bool_val1xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		BooleanOperationValue bool_val1 = (BooleanOperationValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		String op = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		Location bool_val2xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location bool_val2xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		BooleanOperationValue bool_val2 = (BooleanOperationValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                BooleanOperator sym;
                                Code op_code;

                                switch (op) {
                                  case "&&":
                                    op_code = Code.and;
                                    break;
                                  case "||":
                                    op_code = Code.or;
                                    break;
                                  default :
                                    String msg = "Invalid boolean operator" + 
                                                    " from " + opxleft.getLine() + ":" + opxleft.getColumn() + 
                                                    " to " + opxright.getLine() + ":" + opxright.getColumn();
                                    throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                boolean allConst = bool_val1.getIsConst() && bool_val2.getIsConst();
                                Boolean value = null;

                                if (allConst) {
                                  Boolean val1 = (Boolean) bool_val1.getValue();
                                  Boolean val2 = (Boolean) bool_val2.getValue();
                                  switch(op){
                                  case "&&":
                                    value = val1 && val2;
                                    break;
                                  case "||":
                                    value = val1 || val2;
                                    break;
                                  }
                                }

                                Type tipobool = symbolsTable.get("boolean");
                                String idVar = backTables.addTempVar(tipobool.getSize(), tipobool.getTipoSubyacente());
                                String val1id = bool_val1.getVarId();
                                String val2id = bool_val2.getVarId();
                                codi3a.generarC3A(op_code,val1id,val2id,idVar);

                                if (allConst) {
                                  sym = new BooleanOperator(idVar, value);
                                } else {
                                  sym = new BooleanOperator(idVar);
                                }

                                RESULT = sym;
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolean_operation",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // boolean_operation ::= LPAREN boolean_operation RPAREN 
            {
              BooleanOperator RESULT =null;
		Location bool_opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location bool_opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		BooleanOperator bool_op = (BooleanOperator)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                              RESULT = bool_op;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolean_operation",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // boolean_operation ::= OP_LOGICAL_NOT LPAREN boolean_operation RPAREN 
            {
              BooleanOperator RESULT =null;
		Location bool_opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location bool_opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		BooleanOperator bool_op = (BooleanOperator)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                              try {
                                BooleanOperator sym;
                                Type tipobool = symbolsTable.get("boolean");
                                String idVar = backTables.addTempVar(tipobool.getSize(),  tipobool.getTipoSubyacente());
                                codi3a.generarC3A(Code.neg,bool_op.getVarId(),null,idVar);

                                if (bool_op.getIsConst()) {
                                  Boolean val = ! bool_op.getValue().booleanValue();
                                  sym = new BooleanOperator(bool_op.getVarId(), val);
                                } else {
                                  sym = new BooleanOperator(idVar);
                                }
                                RESULT = sym;
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolean_operation",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // boolean_op_value ::= boolean_value 
            {
              BooleanOperationValue RESULT =null;
		Location bool_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location bool_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		BooleanValue bool_val = (BooleanValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try{
                                Boolean val = bool_val.getValue();
                                Type tipobool = symbolsTable.get("boolean");
                                String idVar = backTables.addTempVar(tipobool.getSize(),  tipobool.getTipoSubyacente());
                                codi3a.generarC3A(Code.copy,val.toString(),null,idVar);
                                RESULT = new BooleanOperationValue(idVar, val);
                              }catch(SymTabError e){
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolean_op_value",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // boolean_op_value ::= id_value 
            {
              BooleanOperationValue RESULT =null;
		Location id_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location id_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Identifier id_val = (Identifier)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                
                                BooleanOperationValue sym;
                                String idVar = id_val.getId();
                                Tipo m_v_tipo = id_val.getTipo();
                                if (m_v_tipo != Tipo.darg && m_v_tipo != Tipo.dconst && m_v_tipo != Tipo.dvar) {
                                  String msg = "Invalid arithmetic value type" + 
                                                  " from " + id_valxleft.getLine() + ":" + id_valxleft.getColumn() + 
                                                  " to " + id_valxright.getLine() + ":" + id_valxright.getColumn();
                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                Type tipoVar = symbolsTable.get(id_val.getTypeName());

                                if (TipoSubyacente.TS_BOOLEAN != tipoVar.getTipoSubyacente()) {
                                  String msg = "Boolean Value: Invalid subjacent type" + 
                                                  " from " + id_valxleft.getLine() + ":" + id_valxleft.getColumn() + 
                                                  " to " + id_valxright.getLine() + ":" + id_valxright.getColumn();
                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                if (Tipo.dconst == m_v_tipo) {
                                  Boolean val = (Boolean) id_val.getValue();
                                  sym = new BooleanOperationValue(idVar, val);
                                } else {
                                  sym = new BooleanOperationValue(idVar);
                                }

                                RESULT = sym;
                              } catch (SymTabError e) { 
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolean_op_value",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // boolean_op_value ::= boolean_operation 
            {
              BooleanOperationValue RESULT =null;
		Location bool_opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location bool_opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		BooleanOperator bool_op = (BooleanOperator)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              BooleanOperationValue sym;
                              if (bool_op.getIsConst()) {
                                sym = new BooleanOperationValue(bool_op.getVarId(), bool_op.getValue());
                              } else {
                                sym = new BooleanOperationValue(bool_op.getVarId());
                              }
                              RESULT = sym;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolean_op_value",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // boolean_op_value ::= value_comparison 
            {
              BooleanOperationValue RESULT =null;
		Location comp_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location comp_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		ValuesComparison comp_val = (ValuesComparison)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              BooleanOperationValue sym;
                              String id = new String(comp_val.getVarId());
                              if (comp_val.getIsConst()) {
                                sym = new BooleanOperationValue(id, comp_val.getValue());
                              } else {
                                sym = new BooleanOperationValue(id);
                              }

                              RESULT = sym;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolean_op_value",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // boolean_op_value ::= OP_LOGICAL_NOT value_comparison 
            {
              BooleanOperationValue RESULT =null;
		Location comp_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location comp_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		ValuesComparison comp_val = (ValuesComparison)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                BooleanOperationValue sym;
                                Type tipobool = symbolsTable.get("boolean");
                                String idVar = backTables.addTempVar(tipobool.getSize(), tipobool.getTipoSubyacente());
                                codi3a.generarC3A(Code.not,comp_val.getVarId(),null,idVar);

                                if (comp_val.getIsConst()) {
                                  Boolean val = ! comp_val.getValue().booleanValue();
                                  sym = new BooleanOperationValue(idVar, val);
                                } else {
                                  sym = new BooleanOperationValue(idVar);
                                }

                                RESULT = sym;
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolean_op_value",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // boolean_op_value ::= call_function 
            {
              BooleanOperationValue RESULT =null;
		Location call_fnxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location call_fnxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		CallFunction call_fn = (CallFunction)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                Type tipofunc = symbolsTable.get(call_fn.getFunctionId());
                                Type tipodef = symbolsTable.get(tipofunc.getTypeName());

                                if (TipoSubyacente.TS_BOOLEAN != tipodef.getTipoSubyacente()){
                                  String msg = "Invalid function call " + call_fn.getFunctionId() + 
                                                  " with return type " + tipodef.getTipoSubyacente() + 
                                                  ". Expected :" + TipoSubyacente.TS_BOOLEAN + 
                                                  " from " + call_fnxleft.getLine() + ":" + call_fnxleft.getColumn() + 
                                                  " to " + call_fnxright.getLine() + ":" + call_fnxright.getColumn();
                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                String idVar = backTables.addTempVar(tipodef.getSize(), tipodef.getTipoSubyacente());
                                codi3a.generarC3A(Code.copy,"return",call_fn.getBackendId(),idVar);

                                RESULT = new BooleanOperationValue(idVar);
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolean_op_value",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // boolean_op_value ::= OP_LOGICAL_NOT call_function 
            {
              BooleanOperationValue RESULT =null;
		Location opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		String op = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		Location call_fnxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location call_fnxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		CallFunction call_fn = (CallFunction)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                
                                Type tipofunc = symbolsTable.get(call_fn.getFunctionId());
                                Type tipodef = symbolsTable.get(tipofunc.getTypeName());

                                if (TipoSubyacente.TS_NUMBER != tipodef.getTipoSubyacente()) {
                                  String msg = "Invalid function call " + call_fn.getFunctionId() + 
                                                  " with return type " + tipodef.getTipoSubyacente() + 
                                                  ". Expected :" + TipoSubyacente.TS_NUMBER + 
                                                  " from " + call_fnxleft.getLine() + ":" + call_fnxleft.getColumn() + 
                                                  " to " + call_fnxright.getLine() + ":" + call_fnxright.getColumn();
                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                String idVar = backTables.addTempVar(tipodef.getSize(), tipodef.getTipoSubyacente());
                                codi3a.generarC3A(Code.copy,"return",call_fn.getBackendId(),idVar);
                                codi3a.generarC3A(Code.neg,idVar,null,idVar);

                                RESULT = new BooleanOperationValue(idVar);
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolean_op_value",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // boolean_value ::= BOOL 
            {
              BooleanValue RESULT =null;
		Location bool_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location bool_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		String bool_val = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              Boolean val = Boolean.valueOf(bool_val);
                              RESULT = new BooleanValue(val);
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolean_value",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // boolean_value ::= OP_LOGICAL_NOT boolean_value 
            {
              BooleanValue RESULT =null;
		Location bool_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location bool_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		BooleanValue bool_val = (BooleanValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              Boolean val = ! bool_val.getValue().booleanValue();
                              RESULT = new BooleanValue(val);
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolean_value",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // boolean_value ::= LPAREN boolean_value RPAREN 
            {
              BooleanValue RESULT =null;
		Location bool_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location bool_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		BooleanValue bool_val = (BooleanValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                              RESULT = bool_val;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("boolean_value",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // value_comparison ::= LPAREN value OP_RELATIONAL value RPAREN 
            {
              ValuesComparison RESULT =null;
		Location val1xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).xleft;
		Location val1xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).xright;
		Value val1 = (Value)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		Location opxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location opxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		String op = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location val2xleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location val2xright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		Value val2 = (Value)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                              try{
                                ValuesComparison sym;

                                Tipo type1 = val1.getTipo();
                                TipoSubyacente subType1;

                                if(val1.getTipo() == Tipo.dnull){
                                  subType1 = val1.getTipoSubyacente();
                                }else{
                                  if(type1 != Tipo.dvar && type1 != Tipo.dconst && type1 != Tipo.darg && type1 != Tipo.dfun) {
                                    String msg = "Value 1 of comparison wrong type" + 
                                    " from " + val1xleft.getLine() + ":" + val1xleft.getColumn() + 
                                    " to " + val1xright.getLine() + ":" + val1xright.getColumn();
                                    throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                  }
                                  Type dtype_type = symbolsTable.get(val1.getTypeName());
                                  subType1 = dtype_type.getTipoSubyacente();
                                }
                                // SAME FOR VALUE2
                                Tipo type2 = val2.getTipo();
                                TipoSubyacente subType2;

                                if(val2.getTipo() == Tipo.dnull){
                                  subType2 = val2.getTipoSubyacente();
                                }else{
                                  if(type2 != Tipo.dvar && type2 != Tipo.dconst && type2 != Tipo.darg && type2 != Tipo.dfun) {
                                    String msg = "Value 2 of comparison wrong type" + 
                                    " from " + val2xleft.getLine() + ":" + val2xleft.getColumn() + 
                                    " to " + val2xright.getLine() + ":" + val2xright.getColumn();
                                    throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                  }
                                  Type dtype_type = symbolsTable.get(val2.getTypeName());
                                  subType2 = dtype_type.getTipoSubyacente();
                                }

                                //Check same subtype
                                if(subType1 != subType2) {
                                  String msg = "Value 1 subtype is different from value 2" + 
                                  " from " + val2xleft.getLine() + ":" + val2xleft.getColumn() + 
                                  " to " + val2xright.getLine() + ":" + val2xright.getColumn();
                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                Code op_code = Code.EQ;
                                switch(op){
                                  case "==":
                                    op_code = Code.EQ;
                                    break;
                                  case "!=":
                                    op_code = Code.NE;
                                    break;
                                  case "<":
                                    if(subType1 != TipoSubyacente.TS_NUMBER) {
                                      String msg = "The operator (" + op + ") only works with integer subtypes" + 
                                      " from " + opxleft.getLine() + ":" + opxleft.getColumn() + 
                                      " to " + opxright.getLine() + ":" + opxright.getColumn();
                                      throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                    }
                                    op_code = Code.LT;
                                    break;
                                  case "<=":
                                    if(subType1 != TipoSubyacente.TS_NUMBER) {
                                      String msg = "The operator (" + op + ") only works with integer subtypes" + 
                                      " from " + opxleft.getLine() + ":" + opxleft.getColumn() + 
                                      " to " + opxright.getLine() + ":" + opxright.getColumn();
                                      throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                    }
                                    op_code = Code.LE;
                                    break;
                                  case ">":
                                    if(subType1 != TipoSubyacente.TS_NUMBER) {
                                      String msg = "The operator (" + op + ") only works with integer subtypes" + 
                                      " from " + opxleft.getLine() + ":" + opxleft.getColumn() + 
                                      " to " + opxright.getLine() + ":" + opxright.getColumn();
                                      throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                    }
                                    op_code = Code.GT;
                                    break;
                                  case ">=":
                                    if(subType1 != TipoSubyacente.TS_NUMBER) {
                                      String msg = "The operator (" + op + ") only works with integer subtypes" + 
                                      " from " + opxleft.getLine() + ":" + opxleft.getColumn() + 
                                      " to " + opxright.getLine() + ":" + opxright.getColumn();
                                      throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                    }
                                    op_code = Code.GE;
                                    break;
                                }

                                boolean allConst = val1.getIsConst() && val2.getIsConst();

                                Boolean val = null;
                                if(allConst){
                                  switch (op) {

                                    case "==":
                                      if(subType1 == TipoSubyacente.TS_NUMBER){
                                        val = (Integer) val1.getValue() == (Integer) val2.getValue();
                                      }
                                      if(subType1 == TipoSubyacente.TS_STRING){
                                        val = ((String)val1.getValue()).equals((String) val2.getValue());
                                      }
                                      if(subType1 == TipoSubyacente.TS_BOOLEAN){
                                        val = (Boolean) val1.getValue() == (Boolean) val2.getValue();
                                      }
                                      break;

                                    case "!=":
                                      if(subType1 == TipoSubyacente.TS_NUMBER){
                                        val = (Integer) val1.getValue() != (Integer) val2.getValue();
                                      }
                                      if(subType1 == TipoSubyacente.TS_STRING){
                                        val = !((String)val1.getValue()).equals((String) val2.getValue());
                                      }
                                      if(subType1 == TipoSubyacente.TS_BOOLEAN){
                                        val = (Boolean) val1.getValue() != (Boolean) val2.getValue();
                                      }
                                      break;

                                    // Integer operators
                                    case "<":
                                      val = (Integer) val1.getValue() < (Integer) val2.getValue();
                                      break;
                                    case "<=":
                                      val = (Integer) val1.getValue() <= (Integer) val2.getValue();
                                      break;
                                    case ">":
                                      val = (Integer) val1.getValue() > (Integer) val2.getValue();
                                      break;
                                    case ">=":
                                      val = (Integer) val1.getValue() >= (Integer) val2.getValue();
                                      break;
                                  }
                                }

                                Type booltipo = symbolsTable.get("boolean");
                                String idVar = backTables.addTempVar(booltipo.getSize(), booltipo.getTipoSubyacente());

                                if (allConst) {
                                  sym = new ValuesComparison(idVar, val);
                                } else {
                                  sym = new ValuesComparison(idVar);
                                }

                                codi3a.generarC3A(op_code,val1.getVarId(),val2.getVarId(),idVar);

                                RESULT = sym;
                              }catch(SymTabError e){
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("value_comparison",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // value_comparison ::= LPAREN value_comparison RPAREN 
            {
              ValuesComparison RESULT =null;
		Location cmp_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location cmp_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		ValuesComparison cmp_val = (ValuesComparison)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                              RESULT = cmp_val;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("value_comparison",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // cond ::= boolean_op_value 
            {
              Condition RESULT =null;
		Location bool_valxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location bool_valxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		BooleanOperationValue bool_val = (BooleanOperationValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                String idvar = bool_val.getVarId();
                                String t_label = backTables.addEtiq();
                                String f_label = backTables.addEtiq();

                                labelTrueStack.push(t_label);
                                labelFalseStack.push(f_label);

                                codi3a.generarC3A(Code.jump_cond,idvar,"true",t_label);
                                codi3a.generarC3A(Code.go_to,null,null,f_label);

                                RESULT = new Condition();
                              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cond",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // cond_t ::= 
            {
              CondTrue RESULT =null;
		
                                String label = labelTrueStack.pop();
                                codi3a.generarC3A(Code.skip,null,null,label);
                                RESULT = new CondTrue();
                              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cond_t",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // cond_f ::= 
            {
              CondFalse RESULT =null;
		
                                String label = labelFalseStack.pop();
                                codi3a.generarC3A(Code.skip,null,null,label);
                                RESULT = new CondFalse();
                              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("cond_f",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // instruction_if ::= IF cond LBRACE block_in cond_t instructions block_out RBRACE instruction_elif instruction_else 
            {
              InstructionIf RESULT =null;
		
                              RESULT = new InstructionIf();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction_if",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // m_end ::= EMPTY 
            {
              End RESULT =null;
		
                              String label = backTables.addEtiq();
                              codi3a.generarC3A(Code.go_to,null,null,label);
                              RESULT = new End(label);
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("m_end",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // instruction_elif ::= m_end ELIF cond_f cond LBRACE block_in cond_t instructions block_out RBRACE instruction_elif 
            {
              ElseIf RESULT =null;
		Location mendxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)).xleft;
		Location mendxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)).xright;
		End mend = (End)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-10)).value;
		
                              String label = mend.getLabel();
                              codi3a.generarC3A(Code.skip,null,null,label);

                              RESULT = new ElseIf();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction_elif",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // instruction_elif ::= 
            {
              ElseIf RESULT =null;
		
                              RESULT = new ElseIf();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction_elif",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // instruction_else ::= m_end ELSE LBRACE block_in cond_f instructions block_out RBRACE 
            {
              Else RESULT =null;
		Location mendxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).xleft;
		Location mendxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).xright;
		End mend = (End)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		
                              String label = mend.getLabel();
                              codi3a.generarC3A(Code.skip,null,null,label);
                              RESULT = new Else();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction_else",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // instruction_else ::= cond_f 
            {
              Else RESULT =null;
		
                              RESULT = new Else();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction_else",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // m_while ::= EMPTY 
            {
              WhileLabel RESULT =null;
		
                              String label = backTables.addEtiq();
                              codi3a.generarC3A(Code.skip,null,null,label);
                              RESULT = new WhileLabel(label);
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("m_while",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // instruction_while ::= WHILE m_while cond LBRACE block_in cond_t instructions block_out RBRACE 
            {
              InstructionWhile RESULT =null;
		Location mwhilexleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).xleft;
		Location mwhilexright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).xright;
		WhileLabel mwhile = (WhileLabel)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		
                              String loop = mwhile.getLabel();
                              codi3a.generarC3A(Code.go_to,null,null,loop);
                              String end = labelFalseStack.pop();
                              codi3a.generarC3A(Code.skip,null,null,end);
                              RESULT = new InstructionWhile();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction_while",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // instruction_for ::= FOR LPAREN for_body RPAREN LBRACE block_in cond_t instructions block_out RBRACE 
            {
              InstructionFor RESULT =null;
		Location forBodyxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).xleft;
		Location forBodyxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).xright;
		ForBody forBody = (ForBody)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		
                              String intro = forBody.getLabel();
                              codi3a.generarC3A(Code.go_to,null,null,intro);
                              String end = labelFalseStack.pop();
                              codi3a.generarC3A(Code.skip,null,null,end);
                              RESULT = new InstructionFor();
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction_for",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // label_for ::= EMPTY 
            {
              ForLabel RESULT =null;
		
                              String label = backTables.addEtiq();
                              codi3a.generarC3A(Code.skip,null,null,label);
                              RESULT = new ForLabel(label);
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("label_for",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // for_body ::= declaration SEMICOLON label_for cond SEMICOLON label_post_for operator_assig 
            {
              ForBody RESULT =null;
		Location labelForxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).xleft;
		Location labelForxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).xright;
		ForLabel labelFor = (ForLabel)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		Location labelPostForxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location labelPostForxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		LabelPostFor labelPostFor = (LabelPostFor)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                                    String label = labelFor.getLabel();
                                    codi3a.generarC3A(Code.go_to,null,null,label);
                                    RESULT = new ForBody(labelPostFor.getLabel());
                                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("for_body",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // label_post_for ::= EMPTY 
            {
              LabelPostFor RESULT =null;
		
                              String label = backTables.addEtiq();
                              codi3a.generarC3A(Code.skip,null,null,label);
                              RESULT = new LabelPostFor(label);
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("label_post_for",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // call_function ::= ID LPAREN RPAREN 
            {
              CallFunction RESULT =null;
		Location fun_idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location fun_idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		String fun_id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location lpxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location lpxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		Object lp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		Location rpxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location rpxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Object rp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                // Check if function and has params
                                int nparams = symbolsTable.getNumParams(fun_id);
                                if (nparams > 0 ) {
                                  String msg = "Missing parameters. Function " + fun_id + 
                                                  " has " + nparams + " parameters" + 
                                                  " from " + lpxleft.getLine() + ":" + lpxleft.getColumn() + 
                                                  " to " + rpxright.getLine() + ":" + rpxright.getColumn();
                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                Type fun_type = symbolsTable.get(fun_id);
                                String backId = fun_type.getBackendId();
                                codi3a.generarC3A( Code.call, 0 + "", null, backId );

                                RESULT = new CallFunction(fun_id, backId);
                              } catch (SymTabError e) {
                                String msg = e.getMessage() + 
                                " from " + fun_idxleft.getLine() + ":" + fun_idxleft.getColumn() + 
                                " to " + fun_idxright.getLine() + ":" + fun_idxright.getColumn();
                                throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("call_function",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // call_function ::= call_body RPAREN 
            {
              CallFunction RESULT =null;
		Location bodyxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location bodyxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		CallBody body = (CallBody)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		Location rpxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location rpxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Object rp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                int params_body = body.getNumParams();
                                String idfunc = body.getFunId();
                                int params_fun = symbolsTable.getNumParams(idfunc);

                                if (params_fun != params_body) {
                                  String msg = "Missing some parameters. Function " + idfunc + 
                                  " has " + params_fun + " parameters" + 
                                  " from " + bodyxleft.getLine() + ":" + bodyxleft.getColumn() + 
                                  " to " + rpxright.getLine() + ":" + rpxright.getColumn();
                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                String fun_backId = body.getFunBackId();
                                codi3a.generarC3A( Code.call, params_fun + "", null, fun_backId );

                                RESULT = new CallFunction(idfunc, fun_backId);
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("call_function",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // call_body ::= call_body COMMA value 
            {
              CallBody RESULT =null;
		Location bodyxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location bodyxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		CallBody body = (CallBody)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location valuexleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location valuexright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Value value = (Value)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                String fun_id = body.getFunId();
                                int nparams = body.getNumParams();
                                TipoSubyacente subtipo;

                                if (value.getTipo() == Tipo.dnull){
                                  subtipo = value.getTipoSubyacente();
                                } else {
                                  if(value.getTipo() != Tipo.dvar && value.getTipo() != Tipo.dconst && value.getTipo() != Tipo.darg){
                                    String msg = fun_id + ". Incorrect type for param " + nparams + 
                                    " from " + valuexleft.getLine() + ":" + valuexleft.getColumn() + 
                                    " to " + valuexright.getLine() + ":" + valuexright.getColumn();
                                    throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                  }
                                  Type tipo_val = symbolsTable.get(value.getTypeName());
                                  subtipo = tipo_val.getTipoSubyacente();
                                }

                                //Check param type with function param type
                                Type tipoparam = symbolsTable.getParam(fun_id, nparams);
                                TipoSubyacente subtipoparam = symbolsTable.get(tipoparam.getTypeName()).getTipoSubyacente();

                                if (subtipoparam != subtipo){
                                  String msg = fun_id + ". Incorrect type for param " + nparams + 
                                  ". Expected " + subtipo + " but got " + subtipoparam + 
                                  " from " + valuexleft.getLine() + ":" + valuexleft.getColumn() + 
                                  " to " + valuexright.getLine() + ":" + valuexright.getColumn();
                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                String bid_func = body.getFunBackId();
                                codi3a.generarC3A(Code.param,value.getVarId(),null,bid_func);

                                RESULT = new CallBody(fun_id, bid_func, nparams+1);
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("call_body",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // call_body ::= ID LPAREN value 
            {
              CallBody RESULT =null;
		Location fun_idxleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xleft;
		Location fun_idxright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).xright;
		String fun_id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Location valuexleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xleft;
		Location valuexright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.peek()).xright;
		Value value = (Value)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                              try {
                                TipoSubyacente subtipo;
                                if (value.getTipo() == Tipo.dnull) {
                                  subtipo = value.getTipoSubyacente();
                                } else {
                                  if (Tipo.dvar != value.getTipo() && Tipo.dconst != value.getTipo() && Tipo.darg != value.getTipo()){
                                    String msg = fun_id + ". Incorrect type for param 0" + 
                                  " from " + valuexleft.getLine() + ":" + valuexleft.getColumn() + 
                                  " to " + valuexright.getLine() + ":" + valuexright.getColumn();
                                    throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                  }
                                  Type value_type = symbolsTable.get(value.getTypeName());
                                  subtipo = value_type.getTipoSubyacente();
                                }

                                //Check parameter type with function parameter type
                                Type tipoparam = symbolsTable.getParam(fun_id, 0);
                                TipoSubyacente subtipoparam = symbolsTable.get(tipoparam.getTypeName()).getTipoSubyacente();

                                if (subtipoparam != subtipo) {
                                  String msg = fun_id + ". Incorrect type for param 0. Expected " + subtipo + 
                                  " but got " + subtipoparam + 
                                  " from " + valuexleft.getLine() + ":" + valuexleft.getColumn() + 
                                  " to " + valuexright.getLine() + ":" + valuexright.getColumn();
                                  throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                                }

                                Type tipofunc = symbolsTable.get(fun_id);
                                String bid_func = tipofunc.getBackendId();
                                codi3a.generarC3A(Code.param,value.getVarId(),null,bid_func);
                                RESULT = new CallBody(fun_id, bid_func, 0 + 1);
                              } catch (SymTabError e) {
                                String msg = e.getMessage() + 
                                " from " + fun_idxleft.getLine() + ":" + fun_idxleft.getColumn() + 
                                " to " + fun_idxright.getLine() + ":" + fun_idxright.getColumn();
                                throw new CompilerError(msg, CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("call_body",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // instruction_out ::= PRINT LPAREN value RPAREN 
            {
              InstructionOut RESULT =null;
		Location valuexleft = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xleft;
		Location valuexright = ((java_cup.runtime.ComplexSymbolFactory.ComplexSymbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).xright;
		Value value = (Value)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                              try {
                                String IdVar = value.getVarId();
                                TipoSubyacente subtype;

                                if (Tipo.dnull == value.getTipo()) {
                                  subtype = value.getTipoSubyacente();
                                } else {
                                  Type tipovar = symbolsTable.get(value.getTypeName());
                                  subtype = tipovar.getTipoSubyacente();
                                }
                                if (Tipo.dnull == value.getTipo() && TipoSubyacente.TS_STRING == value.getTipoSubyacente()) {
                                  IdVar = backTables.addTemporalStringVariable(value.getStringSize(), (String) value.getValue());
                                  codi3a.generarC3A( Code.print, subtype.toString(), (String) value.getValue(), IdVar );
                                } else {
                                  codi3a.generarC3A(Code.print,subtype.toString(),null,IdVar);
                                }
                                RESULT = new InstructionOut();
                              } catch (SymTabError e) {
                                throw new CompilerError(e.getMessage(), CompilerError.ErrorType.SEMANTIC, filenamePath);
                              }
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("instruction_out",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // EMPTY ::= 
            {
              Empty RESULT =null;
		 RESULT = new Empty(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EMPTY",52, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
